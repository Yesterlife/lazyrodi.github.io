{"meta":{"title":"Lazy Rodriguez","subtitle":null,"description":null,"author":"Lazy Rodriguez","url":"http://lazyrodi.github.io"},"pages":[{"title":"","date":"2016-07-13T11:47:25.185Z","updated":"2016-07-13T11:47:25.185Z","comments":false,"path":"misc/DocumentWordParser.html","permalink":"http://lazyrodi.github.io/misc/DocumentWordParser.html","excerpt":"","text":"DocumentWordParser function clickSubmit() { var result_canvas = document.getElementById('result-canvas'); var doc = document.getElementById('doc-textarea').value; if (doc === '') { result_canvas.innerHTML = ''; result_canvas.style.display = \"none\"; } else { result_canvas.innerHTML = fill_data(parse_doc(doc)); result_canvas.style.display = \"block\"; } }; function fill_data(objarr) { var ret = \"WordFrequency\"; objarr.sort(function(a, b) { return b.value - a.value; }); for (var i = 0; i < objarr.length; i++) { ret += \"\" + objarr[i].key + \"\" + objarr[i].value + \"\"; } return ret + \"\"; } function parse_doc(doc) { var obj = {}; var tmp = []; var objarr = []; doc = doc.toLowerCase().replace(/\\,|\\.|\\?|\\!|\\'|\\\"|\\[|\\]|\\(|\\)|\\{|\\}/gi,\"\"); tmp = doc.split(/ |\\n|\\t/); for(var i = 0; i < tmp.length; i++) { var item = tmp[i]; if (item !== '') { if (obj.hasOwnProperty(item)) { obj[item]++; } else { obj[item] = 1; } } } for (var pr in obj) { objarr.push({key:pr, value:obj[pr]}); } return objarr; } window.onload = function () { document.getElementById('result-canvas').style.display = \"none\"; } body { font-family: consolas; background-color: #607D8B; } textarea, li { font-family: consolas; font-size: 10pt; } header { color: #FFFFFF; height: 70px; } footer { clear: both; height: 70px; font-size: 9pt; color: #FFFFFF; margin-top: 5px; } p { margin-left: 5px; } #readme, #doc-textarea, #result-canvas { border: 1px solid #aaaaaa; border-radius: 3px; } #content-area { background-color: #F7F7F7; padding: 10px; overflow: hidden; } #readme { background-color: #607D8B; color: #FFFFFF; padding: 1px; margin-bottom: 10px; } #column-left { width: 49%; float: left; } #column-right { width: 50%; float: right; } #doc-textarea { width: 100%; height: 300px; resize: none; } #btn-submit { width: 100px; height: 30px; margin-top: 5px; background-color: #4CAF50; color: #FFFFFF; border: none; cursor: pointer; float: right; } #result-canvas { font-size: 10pt; overflow-x: auto; } #table-result { margin: 5px; } Document Word Parser Parse the document word by word. Input document in textarea left side. Run You can see word-frequency on the right side. Ignore uppercase/lowercase and some characters-, . ' \" ( ) { } [ ] ? !-. lazyrodi@gmail.com, 2016"},{"title":"","date":"2016-07-19T13:50:42.740Z","updated":"2016-07-19T13:50:42.740Z","comments":false,"path":"bookmark/index.html","permalink":"http://lazyrodi.github.io/bookmark/index.html","excerpt":"","text":"Acronyms &amp; Standard Acronym finder Gartner IT Glossary ISO Algorithm Dovelet - www.Dovelet.com Project Euler - Project Euler Algospot - Algospot Algorithms - @tutorialhorizon Android Android Design Guide Learn Android - Tutorials Point Architecture (not Dev) Blog_Jacoby - 멋진 건축물들의 사진을 공유해 주심 CharacterSet Ascii Table - Ascii 7 Table KSC5601 - tapito - KSC5601 Table에 대한 tapito님의 자료 KSC5601 - jchern - KSC5601 Table에 대한 jchern님의 자료 UCS-2 - Columbia Univ.에서 제공하는 UCS-2 Table GSM Character Set - Wiki : GSM-7bit Table 및 GSM-8bit에 대해서도 설명 Community and Portal Devpia Clien Parkoz KLDP Stack overflow Source Forge OKKY GSM Arena Ruliweb C++ cplusplus.com C++ Coding Standard Deep Learning Deep-learning papers Design materialpalette - Android view를 template으로 Material color를 적용해볼 수 있음 pantone color finder - PANTONE Color를 검색해볼 수 있음 IconFinder Google Art Project - 구글에서 제공하는 온라인 가상 미술관 서비스 Blog_MONODREAM Economy DART - 대한민국 전자공시스템 Font Google Fonts - Google에서 제공하는 폰트들. 웹 폰트로도 제공. DaFont Font Awesome Naver Seoul GIT Git 브랜치 배우기 - GIT을 쉽게 배울수 있는 Site Progit - GIT에 대한 교과서(?), https://git-scm.com/book/ko/v2 에서 PDF를 Download받을 수도 있음 Hardware 코코아팹 - 오픈소스 하드웨어에 대해 다루는 커뮤니티. 아두이노 교육. HTTP HTTP - Hypertext Transfer Protocol - HTTP/1.1 IDE, Editor ATOM - ATOM SublimeText3 - Sublime Text 3 VIM - Joins WIKI에서 설명한 VIM 사용법 Visual Studio - Microsoft Visual Studio EditPlus Eclipse - Eclipse Stan4j Memory Analyzer Internet IETF - The Internet Engineering Task Force IETF Tools - RFC 문서를 편하게 찾을 수 있음 Java Oracle - JDK Download JavaDoc 7 - Java 7 Document. http://docs.oracle.com/javase/7/docs 에서 숫자만 바꾸면 다른 버전도 확인 가능. 남궁성의 코드초보스터디 - JAVA의 정석 저자이신 남궁성님의 카페 강이의 JAVA 강좌 Learn Java - Tutorials Point JavaScript JavaScript Pattern - shichuan.github.io : JavaScript Pattern 모음 JavaScript 재입문하기 - Mozilla 재단에서 제공하는 JavaScript 강의. State of the JavaScript Landscape: A Map for Newcomers 한글 번역 Language 621+ Programming Resources - 각종 언어의 Reference 및 학습 자료를 제공. Marketing Blog_개발마케팅연구소 Mobile communications 3GPP - 3GPP (GSM) 3GPP2 - 3GPP2 (CDMA) TIA - 미국통신산업협회(Telecommunication Industry Association) OMA - Open Mobile Alliance: MMS, WAP Push 등의 규격을 정의 MCC/MNC - Wiki: MCC/MNC를 확인할 수 있음 MOOC 생활코딩 Coursera Udacity KhanAcademy KMooc WikiDocs - 온라인 책을 제작 공유하는 플랫폼 서비스 Operation 한국저작권위원회 Organization 정보통신정책연구원 - KISDI (정보통신정책연구원) 한국관광공사 Perl 한국 펄 사용자 모임 - Perl 강좌 및 커뮤니티 Python 점프 투 파이썬 왕초보를 위한 Python 2.7 Think Python QA STEN ISTQB KSTQB ISO/IEC/IEEE 29119 Software Testing Regular Expression REGEXPER Ruby on rails Ruby guide Ruby tutorial book Integrating rails and bootstrap SMS (Short Message Service) PDU Parser - JavaScript로 만든 Raw PDU Parsing tool. SW Engineering Popular Coding Convention Swift Swift 언어 개발문서 Utility 반디집 - 압축 프로그램 꿀뷰 - 이미지 뷰어 Cygwin Putty Virtual Box Daemon Zoomit draw.io - UML 그리기 Favicon Generator UX Blog_UXD Trend Web apache - Apache getBootstrap - Bootstrap bootstrap-material-design jQuery - jQuery nodejs - nodejs w3schools - HTML, CSS, JavaScript, SQL, PHP, jQuery, Bootstrap JavaEE 6 Tutorial Jonathan Suh - 이 분 대박… Web Plugins DISQUS - Comment plugin InterestCycling 도싸 - 도시의 싸이클 Endomondo Strava VeloViewer - 1년치 Strava 기록을 정산하여 한 화면으로 볼 수 있게 해줌 ProbikeKit - 쇼핑몰. ca, uk 등 잘 선택할 것. Wiggle - 쇼핑몰. 주로 DHB 제품 구매 시 사용 Drama / Movie DramaNote - 일본 드라마 정보 Jamak.kr - 드라마 자막 제공 Food Lovecook - 조리사 자격증 관련 정보 Health Monsterzym Blog_흑자쇠질 - 비속어가 섞여있으므로 주의. Blog_트레이너 이우제 Music 지음아이 - 노래 가사 등 제공 Snow Boarding 헝그리보더 - Facebook : hungryboarders 정보처리 기술사 Blog_Withme DocumentsETC Valve 입사 핸드북 Github Bootstrap Awesome interview"},{"title":"","date":"2016-07-12T15:38:59.507Z","updated":"2016-07-11T12:26:37.165Z","comments":false,"path":"about/index.html","permalink":"http://lazyrodi.github.io/about/index.html","excerpt":"","text":"Location Seoul, South Korea Experience Software engineer LG Electronics Mobile Communications (01/2010 ~ current) Skill Android Java C JavaScript Interest Ruby on rails Node.js Certifications Engineer Information Processing (Korea) TRIZ Level 1 ISTQB CTFL Like Cycling Snowboarding"},{"title":"","date":"2016-07-16T12:46:01.008Z","updated":"2016-07-16T12:35:51.097Z","comments":false,"path":"misc/MyFavoriteColors.html","permalink":"http://lazyrodi.github.io/misc/MyFavoriteColors.html","excerpt":"","text":"My Favorite Colors window.onload = function () { } #bg-black { background-color: #000000; } #rodicolor-1-level-1 { background-color:#607D8B; color: #EEEEEE; } #rodicolor-1-level-2 { background-color:#90ADBB; color: #EEEEEE; } #rodicolor-1-level-3 { background-color:#C0DDEB; color: #333333; } #rodicolor-2-level-1 { background-color:#FFA000; color: #777777; } #rodicolor-2-level-2 { background-color:#FFC107; color: #777777; } #rodicolor-2-level-3 { background-color:#FFECB3; color: #777777; } #rodicolor-3-level-1 { background-color:#212121; color: #FFFFFF; } #rodicolor-3-level-2 { background-color:#616161; color: #FFFFFF; } #rodicolor-3-level-3 { background-color:#9E9E9E; color: #FFFFFF; } #rodicolor-4-level-1 { background-color:#303F9F; color: #EEEEEE; } #rodicolor-4-level-2 { background-color:#2F61E5; color: #EEEEEE; } #rodicolor-4-level-3 { background-color:#428AFF; color: #EEEEEE; } #rodicolor-5-level-1 { background-color:#243141; color: #EEEEEE; } #rodicolor-5-level-2 { background-color:#3E5165; color: #EEEEEE; } #rodicolor-5-level-3 { background-color:#5B6F83; color: #EEEEEE; } #rodicolor-6-level-1 { background-color:#E0225F; color: #EEEEEE; } #rodicolor-6-level-2 { background-color:#F93C78; color: #EEEEEE; } #rodicolor-6-level-3 { background-color:#FC6595; color: #EEEEEE; } #rodicolor-7-level-1 { background-color:#D8D380; color: #303F9F; } #rodicolor-7-level-2 { background-color:#E8E4A7; color: #303F9F; } #rodicolor-7-level-3 { background-color:#F3F2CC; color: #303F9F; } I love this color 1 bg: #607D8B, font: #EEEEEE bg: #90ADBB, font: #EEEEEE bg: #C0DDEB, font: #333333 2 bg: #FFA000, font: #777777 bg: #FFC107, font: #777777 bg: #FFECB3, font: #777777 3 bg: #212121, font: #FFFFFF bg: #616161, font: #FFFFFF bg: #9E9E9E, font: #FFFFFF 4 bg: #303F9F, font: #EEEEEE bg: #2F61E5, font: #EEEEEE bg: #428AFF, font: #EEEEEE 5 bg: #243141, font: #EEEEEE bg: #3E5165, font: #EEEEEE bg: #5B6F83, font: #EEEEEE 6 bg: #E0225F, font: #EEEEEE bg: #F93C78, font: #EEEEEE bg: #FC6595, font: #EEEEEE 7 bg: #D8D380, font: #EEEEEE bg: #E8E4A7, font: #EEEEEE bg: #F4F2CC, font: #EEEEEE lazyrodi@gmail.com &copy; 2016"}],"posts":[{"title":"Android Interview","slug":"2016-07-19-interview-android","date":"2016-07-19T10:00:00.000Z","updated":"2016-07-19T13:49:29.588Z","comments":true,"path":"2016/07/19/2016-07-19-interview-android/","link":"","permalink":"http://lazyrodi.github.io/2016/07/19/2016-07-19-interview-android/","excerpt":"","text":"Android application을 생성할 때 중요한 폴더 및 파일을 설명하라. 다음 AndroidManifest.xml 파일을 설명하라. Activity에 대해 간단히 설명하라. Android Architecture의 key component는 무엇인가? Intent에 대해 설명하라. Android에서 SMS를 발신하기 위해서는 어떻게 해야 하는지 설명하라. SMSManager class에 대해 설명하라. 당신의 application에서 어떻게 Messaging application을 사용할 수 있겠는가? Android에서 사용할 수 있는 Data storage에는 어떤 것들이 있는가? SharedPreference에 대해 예시와 함께 설명하라. Android application을 생성할 때 중요한 폴더 및 파일을 설명하라.ValueDescriptionsrc.java파일을 포함한다.genCompiler가 자동으로 생성하는 Resource파일인 R.java 파일을 가지고 있다. 이 파일은 수정해서는 아니된다.libraryandroid.jar 파일을 포함한다. 해당 Android application에 대한 library들이다.assetsHTML, text, database등의 파일을 포함한다.bin빌드 후 생성되는 .apk 파일을 포함한다.resApplication에서 사용하는 리소스 파일들을 포함한다. 다음 AndroidManifest.xml 파일을 설명하라. Package 이름(@string/app_name)을 포함한다. Version code가 1이고 이는 어플리케이션의 version(몇 번째 release인지)을 나타낸다. Version name이 1.0임을 알 수 있다. android.minSdkVersion이 8이고 이는 이 어플리케이션이 실행될 수 있는 Android OS의 최소 version을 나타낸다. MainActivity에 대한 activity 정보를 확인할 수 있다. Intent-filter를 통해 Main임을 확인할 수 있다. &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.careerride\" android:versionCode=\"1\" android:versionName=\"1.0\"&gt;&lt;uses-sdk android:minSdkVersion=\"8\" android:targetSdkVersion=\"18\" /&gt;&lt;application android:allowBackup=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\"&gt;&lt;activity android:name=\"com.example.careerride.MainActivity\" android:label=\"@string/app_name\"&gt;&lt;intent-filter&gt;&lt;action android:name=\"android.intent.action.MAIN\" /&gt;&lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;&lt;/intent-filter&gt;&lt;/activity&gt;&lt;/application&gt;&lt;/manifest&gt; Activity에 대해 간단히 설명하라.Activity는 User interface를 보여준다. Android application 생성 시 하나의 activity가 생성되며, 기본 이름은 MainActivity이며 맘대로 이름을 붙일 수 있다. 기본적으로 Activity class를 상속받는다. Android Application은 0개 이상의 Activity를 가질 수 있으며 사용자와의 interaction을 위해 사용한다. Activity는 onCreate()로 시작하여 onDestroy()로 끝나는 Lifecycle을 가지고 있다. packagecom.example.careerride; //Application name careerrideimportandroid.os.Bundle; // Default packagesimportandroid.app.Activity; // Default packagesimportandroid.view.Menu;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);&#125;@OverridepublicbooleanonCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true;&#125;&#125; Android Architecture의 key component는 무엇인가? Linux Kernel Libraries Android Framework Android Applications Intent에 대해 설명하라.Android의 기본 구성요소(Component)에는 Acivity, Service, ContentProvider, BroadcastReceiver 네 가지가 있는데 이 중 Activity, Service, BroadcastReceiver 사이에 data를 주고 받기 위해 intent를 사용한다. 다른 activity를 호출하거나 service를 시작하거나 broadcast할 수 있다. Intent는 명시적 intent와 암시적 intent 두 가지로 나눌 수 있다. 명시적 intent는 intent를 전달할 class 정보를 포함한다. Intent intent = newIntent (this, SecondActivity.class);startActivity(intent); 암시적 intent는 동작을 원하는 값을 action값으로 하여 URI, MIME type, category 등과 함께 던지면 Android system에서 적절한 application을 찾아서 원하는 동작을 시켜준다. 적절한 application을 찾는 과정에서 다른 application 내의 intent-filter를 검색하여 매칭되는지 확인한다. 암시적 intent를 던질 때 call, sms 등과 같은 특정한 동작을 원할 때에는 자신이 그 동작을 수행할 수 있는 permission을 가지고 있어야 한다. Intent i = newIntent(android.content.Intent.ACTION_VIEW,Uri.parse(“http://www.amazon.com”));startActivity(i);/**/Intent i = newIntent (android.content.Intent.ACTION_DIAL,Uri.parse(“tel:+9923.....”));startActivity(i);/**/Intent i = newIntent (android.content.Intent.ACTION_CALL,Uri.parse(“tel:+9923.....”));startActivity(i);/* permission */&lt;uses-permissionandroid:name=”android.permission.CALL_PHONE”/&gt;&lt;uses-permissionandroid:name=”android.permission.INTERNET”/&gt; Android에서 SMS를 발신하기 위해서는 어떻게 해야 하는지 설명하라. “send sms” Button을 생성한다. AndroidManifest.xml 에 permisson을 설정한다. 다음과 같은 메소드를 만들어서 SMS를 발신한다.publicvoidsendmySMS(View v)&#123; SmsManager sms = SmsManager.getDefault(); sms.sendTextMessage(\"5556\", null, \"Hello from careerRide\", null, null);&#125; SMSManager class에 대해 설명하라.SMS를 발신할 때 사용하는 class이며, 직접적으로 초기화하여 사용할 수 없고 getDefault()를 사용해야 한다. 발신하는 메소드는 sendTextMessage()인데 다음과 같은 파라미터들을 갖는다. destinationAddress: 수신자의 전화번호 scAddress: Service center address (null로 설정해도 된다.) text: 메시지 내용 sentIntent: 메시지가 발신되었음을 알려주는 intent. deliveryIntent: 메시지가 상대방에게 도착하였음을 알려주는 intent. 어플리케이션에서 delivery status option을 체크해줘야 한다. publicvoidsendmySMS(View v)&#123; SmsManager sms = SmsManager.getDefault(); sms.sendTextMessage(\"5556\", null, \"Hello from careerRide\", null, null);&#125; 당신의 application에서 어떻게 Messaging application을 사용할 수 있겠는가?SMS 발신 permission을 얻은 후, Intent를 던지면 Default SMS Application으로 설정되어 있는 Application을 통해 SMS를 발신할 수 있다. Intent intent = new Intent (android.content.Intent.ACTION_VIEW);intent.putExtra(\"address\", \"5556; 5558;\"); // Send the message to multiple recipient.itent.putExtra(\"sms_body\", \"Hello my friends!\");intent.setType(\"vnd.android-dir/mms-sms\");startActivity(intent); Android에서 사용할 수 있는 Data storage에는 어떤 것들이 있는가? SharedPreferences SQLite ContentProvider File Storage Cloud Storage SharedPreference에 대해 예시와 함께 설명하라.SharedPreference는 Android storage 중 가장 간단한 방법을 가진다. Data를 XML 파일에 저장하는데 Key-Value pair로 한다. Primitive data type을 사용할 수 있다. (boolean, float, int, long, string) XML 파일은 data/data/자신의 패키지명(com.a.b)/shared-prefs/ 디렉토리에 저장된다. A Activity에서 저장한 내용도 B Activity에서 가져다가 사용할 수 있다. 저장SharedPreferences sf = getSharedPreferences(\"MyData\", MODE_PRIVATE); // \"Mydata\" XML file, MODE_PRIVATE은 이 어플리케이션에서만 사용하겠다는 의미.SharedPreferences.Editor ed = sf.edit();ed.putString(\"name\", txtusername.getText().toString());ed.putString(\"pass\", txtpassword.getText().toString());ed.commit(); 읽어오기getString(value, default) 형식으로 읽어오면 되며, value가 SharedPreference에 존재하지 않을 때 “default” 값을 가져온다. 그리고 아래 코드에서는 name이나 pass 중 하나라도 못 읽어오면 “No data is found” Toast를 발생시킨다. public static final String DEFAULT = \"N/A\";SharedPreferences sf = getSharedPreferences(\"MyData\", Context.MODE_PRIVATE);String Uname = sf.getString(\"name\", DEFAULT);String UPass = sf.getString(\"pass\", DEFAULT);if(name.equals(DEFAULT) || Pass.equals(DEFAULT)) &#123; Toast.makeText(this, \"No data is found\", Toast.LENGTH_LONG).show();&#125; else &#123; Txtusername.setText(Uname); Txtpassword.setText(UPass) ;&#125; 출처 http://www.careerride.com/android-interview-questions.aspx","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"interview","slug":"Dev/interview","permalink":"http://lazyrodi.github.io/categories/Dev/interview/"}],"tags":[{"name":"interview, android","slug":"interview-android","permalink":"http://lazyrodi.github.io/tags/interview-android/"}]},{"title":"Intent","slug":"2016-07-17-android-intent","date":"2016-07-16T23:00:00.000Z","updated":"2016-07-19T13:49:36.138Z","comments":true,"path":"2016/07/17/2016-07-17-android-intent/","link":"","permalink":"http://lazyrodi.github.io/2016/07/17/2016-07-17-android-intent/","excerpt":"","text":"Android의 기본 Application component에는 다음 네 가지가 있다. ComponentsDescriptionActivity사용자 인터페이스가 있는 화면 하나를 뜻한다.ServiceBackground에서 실행되는 component이다.오랫동안 실행되는 작업이나 원격 프로세스를 위한 작업이 주로 이루어지며 사용자 인터페이스를 제공하지 않는다.(ex. 음악 재생, 파일 다운로드)Content ProviderFile system, Database 등의 저장소를 통합 관리한다.권한이 허가된 경우 다른 application에서 접근 및 수정까지도 가능하다.Broadcast RecieverSystem이나 application은 특정한 상태나 data에 대해 broadcast를 날릴 수 있는데 이를 수신하여 처리한다. 위 기본 요소 중 Activity, Service, Broadcast Reciever는 Intent 라는 비동기 메시지가 전달되어 활성화된다. IntentMessage Object의 일종으로 intent를 사용하여 다른 component들에게 작업을 요청할 수 있다. 기본적으로는 다음 세 가지 목적으로 사용한다. Activity의 시작 Service의 시작 Broadcast의 전달 Activity의 시작 Intent를 startActivity()로 전달하면 새 activity가 실행된다. Activity의 실행 결과를 돌려받고 싶다면 startActivityForResult()를 호출한다. 돌려받은 결과는 onActivityResult()를 구현하여 처리할 수 있다. 결과 또한 intent로 수신한다. Service의 시작 Intent를 startService()로 전달하면 일회성 작업이 수행된다. Client-Server interface로 설계된 service라면 intent를 bindService()로 전달하면 바인딩하여 사용할 수 있다. Broadcast의 전달 Intent를 sendBroadcast(), sendOrderedBroadcast(), sendStickyBroadcast() 중 하나에 담아서 전달한다. 모든 application들에 message를 전달할 때 사용한다. (system에서 전달할 때는 특정 application을 지정해서 전달할 수도 있다.) Intent의 기본 요소ComponentName, Action, Data, Category, Extra, Flags 가 있다. ComponentNameOptional 항목으로 Implicit intent로 사용할 경우 반드시 이름을 명시해야 한다. Service를 시작하는 경우에는 무조건 이 항목을 지정해야 한다. 그렇지 않으면 해당 intent에 어느 service가 응답할지 확신할 수 없고 사용자고 어떤 service가 시작되는지 알 수 없게 된다. ComponentName으로는 application의 패키지명이 포함된 Full-Qualified class name을 사용해야 한다. (ex. com.example.Example.Activity). Intent 생성자를 사용하거나 setComponent(), setClass(), setClassName()을 사용하여 ComponentName을 설정할 수 있다. Action수행할 작업을 나타내며, 특정 application에서 커스터마이징한 action name을 사용할 수도 있지만 일반적으로는 Intent class나 다른 Framework class가 정의한 Action 상수를 사용한다. 커스터마이징할 경우 패키지명을 Prefix(접두사)에 포함시켜야 한다. static final String ACTION_TIMETRAVEL = \"com.example.action.TIMETRAVEL\"; Activity를 시작할 때 아래 두 가지 ACTION을 사용할 수 있다. ACTION_VIEW startActivity()를 사용하며, 해당 Activity가 사용자에게 표시할 정보를 가지고 있을 때(ex. 갤러리) 사용한다. ACTION_SEND Shared intent라고도 하며, startActivity()를 사용한다. 사용자가 다른 application을 통해 공유할 수 있는 data를 가지고 있을 때(ex. 이메일) 사용한다. Intent 생성자를 사용하거나 setAction()을 사용하여 Action을 설정할 수 있다. DataAction을 수행할 data 또는 해당 data의 MIME type을 참조하는 URI Object이다. 일반적으로 action명을 보면 data를 추측할 수 있는데 예를 들어 action이 ACTION_EDIT라면 data에는 편집할 문서의 URI가 들어있어야 한다. Intent 생성 시 URI와 함께 Data type(MIME type)의 지정이 중요하다. 만약 이미지 처리용 application이 있을 때, URI가 비슷하다 할지라도 이 application에서는 오디오 처리를 할 수는 엇다.따라서 MIME type을 지정해주는 것이 좋다. Data URI만 설정하려면 setData()를 사용하고, MIME type만 설정하려면 setType()을 사용하면 된다. 두 가지 모두 사용할 경우 setData()와 setType()은 서로의 값을 덮어버리는 특성이 있으므로 반드시 setDataAndType()을 사용해야 한다. 일반적으로 Action과 Data는 다음과 같은 짝을 갖는 경우가 많다. ActionURIDescriptionACTION_VIEWcontent://contacts/people/11번 사람에 대한 정보를 표시한다.ACTION_DIALcontent://contacts/people/1Dialer에 1번 사람의 번호를 채워서 보여준다.ACTION_VIEWtel:123Dialer에 ‘123’을 채워서 보여준다.ACTION_DIALtel:123Dialer에 ‘123’을 채워서 보여준다.ACTION_EDITcontent://contacts/people/11번 사용자에 대한 정보를 수줭한다.ACTION_VIEWcontent://contacts/people/주소록 리스트를 띄운다. 이 리스트에서 특정 사용자를 선택할 경우 ACTION_VIEW content://contacts/N이 시작된다. 위의 두 가지 주 속성에 더하여, 아래에 설명할 몇 가지의 부 속성을 사용할 수 있다. CategoryOptional 항목이며 Intent를 처리해야 하는 component에 대한 추가 정보를 담고있다. 몇 가지 보편적인 Category의 예이다. CATEGORY_LAUNCHER Application 진입 시 최초의 Activity임을 의미한다. CATEGORY_ALTERNATIVE Data의 일부에 대해 사용자가 사용할 수 있는 대체 action들에 대한 목록을 포함할 것을 의미한다. CATEGORY_BROWSABLE 대상 Activity가 스스로 Web browser에게 자신을 시작할 권한을 주며, link를 통해 참조된 data를 표시하게 한다. 이미지, 이메일, 메시지 등이 해당된다. Category 지정은 addCategory()를 통해서 설정한다. Type Intent data의 명시적인 type(MIME type)을 정의한다. 일반적인 경우 type은 data 자신으로부터 추측할 수 있다. Component Intent에 사용하기 위한 component class의 명시적인 이름을 정의한다. 일반적으로 이 항목은 intent 내의 다른 정보(action, data/type, category)에 의해 정의되고 이를 다룰 수 있는 component에 매칭된다. 만약 이 속성이 세팅될 경우 아무 동작도 수행하지 않으며 이 component는 그 자체로만 사용된다. 이 속성을 정의함으로 인해 모든 다른 Intent 속성들은 optional 항목이 된다. Extras요청한 작업을 수행하기 위한 추가 정보를 담고 있다. Key-Value pair로 이루어져 있다. putExtras() 메소드를 사용하며, 모든 extra data를 갖는 Bundle을 생성하여 직접 putExtras()로 삽입할 수도 있다. 예를 들어, ACTION_SEND로 이메일을 전송할 경우, “받는 사람”을 EXTRA_EMAIL로 지정하고, “제목”을 EXTRA_SUBJECT로 할 수 있다. Intent class는 표준화된 data type들에 대해 많은 EXTRA_*를 지원하고 있다. 자신의 application만의 특정 extra key를 사용해야 할 경우 Package name을 prefix(접두사)로 포함시켜야 한다. static final String EXTRA_GIGAWATTS = \"com.example.EXTRA_GIGAWATTS\"; FlagsIntent class에서 정의하고 있으며, Meta-data 역할을 수행한다. Android system에 activity를 시작할 방법을 알려줄 수도 있고, activity를 시작한 후 어떻게 처리해야 하는 지도 알려줄 수 있다. 지정은 setFlags() 로 하면 된다. Intent의 typeIntent type은 Explicit, Implicit 두 가지가 있다. Explicit intent는 무엇을 할지, Implicit intent는 누구에게 던질지가 중요하다. application의 보안을 위해 Service의 시작 시에는 항상 Explicit intent만 사용하고 Intent filter는 선언하지 않도록 하라. Explicit(명시적) intent새 activity를 시작하거나 service를 시작할 때 사용한다. (ex. File download) 일반적으로 application 안에서 component를 시작할 때 사용한다. 시작할 component의 이름을 Fully-Qualified class name (ex. Abc.Class)으로 지정한다. Explicit intent를 사용할 경우 system이 즉시 지정된 component를 시작한다. 아래 예시는 웹에서 파일을 다운로드 하도록 한 DownloadService를 시작하는 코드이다. // Executed in an Activity, so 'this' is the Context// The fileUrl is a string URL, such as \"http://www.example.com/image.png\"Intent downloadIntent = new Intent(this, DownloadService.class);downloadIntent.setData(Uri.parse(fileUrl));startService(downloadIntent); Implicit(암시적) intent특정 component가 뭔지는 모르지만 현재 application이 수행할 수 없는 일반적인 작업을 다른 application의 component가 처리할 수 있도록 한다. Implicit intent를 사용하면 system이 시작시킬 적절한 component를 찾게 된다. 이 때, intent의 내용을 다른 application들의 Manifest file에 선언된 Intent filter와 대조하는 작업을 거치고, 해당 기능을 수행할 수 있는 application이 여러개가 있다면, 사용자가 선택할 수 있도록 화면을 띄워준다. Intent filter란 Manifest file에 선언한 해당 component가 수신하고자 하는 Intent type에 대한 내용이다. 다른 application들이 여기에 선언한 내용을 기반으로 내 application의 기능을 사용할 수 있게 된다. Intent filter에 아무 것도 선언하지 않는다면 explicit intent로만 수행할 수 있다. 아래 예시는 URI를 사용하지 않고 “text/plain” 정보를 통해 extra 정보를 지정한 후 ACTION_SEND를 통해 implicit intent를 날리는 것이다. // Create the text message with a stringIntent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);sendIntent.setType(\"text/plain\");// Verify that the intent will resolve to an activityif (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(sendIntent);&#125; Implicit intent 사용 시 주의할 점은 startActivity()를 통해 날려도 처리할 application이 전혀 표시되지 않을 수 있다. 이 경우 호출 실패는 물론 application이 죽는다. 어떤 Activity에서라도 해당 intent를 확실히 수신할 수 있도록 하려면 위의 코드처럼 resolveActivity()를 호출하여 미리 확인하자. 결과가 null이 아닌 경우 해당 intent를 처리할 수 있는 application이 최소 하나는 있다는 것을 의미한다. Implicit intent에 응답하는 application이 하나 이상일 경우, 사용자가 수행될 application을 선택할 수 있는데 이 때 띄워주는 메뉴를 app chooser(앱 선택기)라 한다. Android는 사용자에게 항상 같은 application을 사용할 수 있는 옵션을 제공한다. 하지만 특정한 케이스에서, 사용자가 항상 다른 application을 사용해야 한다면 앱 선택기를 명시적으로 표시할 필요가 있다. 앱 선택기를 항상 표시하기 위해 아래와 같이 chooser intent생성 후 createChooser()를 사용하면 된다. Intent sendIntent = new Intent(Intent.ACTION_SEND);...// Always use string resources for UI text.// This says something like \"Share this photo with\"String title = getResources().getString(R.string.chooser_title);// Create intent to show the chooser dialogIntent chooser = Intent.createChooser(sendIntent, title);// Verify the original intent will resolve to at least one activityif (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(chooser);&#125; Intent filter내 application이 수신할 수 있는 Implicit intent가 어떤 것이 있는지 알리려면 application Component에 대한 하나 이상의 intent filter를 Manifest file에 선언해야 한다. Explicit intent는 Component가 어떤 intent filter를 선언했든 무관하게 항상 정의해둔 곳으로 전달된다. 각 Intent filter는 다음과 같은 세 가지 요소 중 하나 이상을 사용하여 허용할 intent type을 정의할 수 있다. &lt;action&gt; 허용된 intent 작업을 name 속성에서 선언한다. Literal string이며 Class 상수가 아니다. &lt;data&gt; 허용된 data type을 선언한다. Data URI(scheme, host, port, path 등)와 MIME type 의 여러가지 내용 중 하나 이상의 속성을 사용한다. &lt;category&gt; 허용된 intent category를 name 속성에서 선언한다. Literal string이며 Class 상수가 아니다. Explicit intent를 수신하기 위해서는 Intent filter 내에 반드시 CATEGORY_DEFAULT를 포 함시켜야 한다. startActivity(), startActivityForResult() 메소드들은 모든 intent를 CATEGORY_DEFAULT를 선언한 것처럼 취급하기 때문에 이 Category를 intent filter에 선언하지 않으면 Activity의 어떤 암시적 intent도 확인되지 않는다. 아래 예시는 Data type이 text인 ACTION_SEND intent를 수신하겠다는 뜻이다. Intent filter 내에 선언한 것들과 하나라도 맞지 않으면 intent가 application으로 전달되지 않는다. &lt;activity android:name=\"ShareActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:mimeType=\"text/plain\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; Intent filter에 등록하지 않았다고 하더라도 다른 application에서 내 application Component의 경로를 알아챌 경우 내 component를 수행할 수 있게 된다. 이 경우를 방어하기 위해 Manifest의 안에 android:exported = false를 설정하면 된다. 아래는 Android developer 사이트에서 제공하는 소셜 공유 application의 Manifest file이다. &lt;activity android:name=\"MainActivity\"&gt; // MainActivity 가 application의 Entry point(진입 지점)이다. &lt;!-- This activity is the main entry, should appear in app launcher --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; // 여기가 주요 진입 지점이며, 어떠한 intent도 바라지 않는 다는 것을 의미한다. &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; // 이 Activity의 icon이 system의 application 시작 관리자에 배치되어야 한다는 것을 나타낸다. // 여기서는 icon을 지정하지 않았으므로 system은 &lt;application&gt; 에서 가져온 아이콘을 사용한다. &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=\"ShareActivity\"&gt; // 컨텐츠 공유를 목적으로 만든 Activity이다. &lt;!-- This activity handles \"SEND\" actions with text data --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\"/&gt; // 다른 application에서 이 action과 &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; // type이 text/plain인 category를 이 application으로 던졌을 때 이 activity를 수행한다. &lt;data android:mimeType=\"text/plain\"/&gt; &lt;/intent-filter&gt; &lt;!-- This activity also handles \"SEND\" and \"SEND_MULTIPLE\" with media data --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\"/&gt; &lt;action android:name=\"android.intent.action.SEND_MULTIPLE\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:mimeType=\"application/vnd.google.panorama360+jpg\"/&gt; &lt;data android:mimeType=\"image/*\"/&gt; &lt;data android:mimeType=\"video/*\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; Pending IntentPendingIntent는 Intent의 wrapper이다. 다른 application에 권한을 위임하여 그 안에 들어있는 intent를 마치 본인 application의 자체 프로세스에서 실행하는 것처럼 사용하는 것이다. 뭔 말인가 싶다. 현재의 application A가 PendingIntent를 만들어서 다른 application이나 컴포넌트에 “내가 너에게 이 intent를 전달할 수 있는 권한을 줄테니 이따가 나 대신 좀 보내줘.” 라고 하는 것이다. 주요 사용 사례는 다음과 같다. 사용자가 이 application의 notification을 통해 task를 수행할 때 intent가 실행되도록 한다(Android system의 NotificationManager가 Intent를 실행한다.). 사용자가 이 application의 Application Widget으로 task를 수행할 때 intent가 실행되도록 한다(Mainscreen application에 Intent를 실행한다.). 지정된 시간에 intent가 실행되도록 선언한다(Android system의 AlarmManager가 Intent를 실행한다.). 예를 들어, 아래 코드는 실행하면 Notification bar에 새 notification이 등록되고 사용자가 이 notification을 터치했을 때 MainActivity로 진입한다. NotificationManager nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);PendingIntent pIntent = PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), PendingIntent.FLAG_UPDATE_CURRENT);Notification.Builder mBuilder = new Notification.Builder(this);mBuilder.setSmallIcon(R.mipmap.ic_launcher);mBuilder.setTicker(\"Notification.Builder\");mBuilder.setWhen(System.currentTimeMillis());mBuilder.setNumber(1);mBuilder.setContentTitle(\"Notification.Builder Title\");mBuilder.setContentText(\"Notification.Builder Massage\");mBuilder.setDefaults(Notification.DEFAULT_SOUND | Notification.DEFAULT_VIBRATE);mBuilder.setContentIntent(pIntent);mBuilder.setAutoCancel(true);mBuilder.setPriority(Notification.PRIORITY_MAX);nm.notify(1, mBuilder.build()); 각 Intent object는 특정한 유형의 component(Activity, Service, BroadcastReceiver)가 처리하도록 설계되어 있다. 따라서 PendingIntent도 이러한 사항을 염두에 두고 생성해야 한다. PendingIntent를 사용하는 경우 직접적으로 startActivity() 등의 호출을 사용하지 않으므로 적절하게 세팅해줘야 한다. Activity 시작 Intent: PendingIntent.getActivitiy() Service 시작 Intent: PendingIntent.getService() BroadcastReceiver 시작 Intent: PendingIntent.getBroadcast() Intent 살펴보기system이 Activity를 시작하라는 implicit intent를 수신하면 system은 해당 intent에 대한 최선의 activity를 검색한다. 이 때 판단 근거가 아래 세 가지이다. Intent Action Intent Data (URI와 data type) Intent Category Action test이 Filter를 통과하려면 아래 나열된 작업 중 하나와 일치해야 한다. &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.EDIT\" /&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; ...&lt;/intent-filter&gt; Category testIntent 내의 모든 Category가 filter 내의 category와 일치해야 한다. Filter 내의 category 수가 더 많은 것은 상관 없다. Intent의 category가 아무 것도 선언되어 있지 않으면 모두 통과할 수 있다. &lt;intent-filter&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; ...&lt;/intent-filter&gt; Android는 CATEGORY_DEFAULT category를 startActivity() 및 startActivityForResult()에 전달된 모든 implicit intent에 적용한다. 따라서 Activity가 implicit intent를 수신하기 위해서는 intent filter 내에 “android.intent.category.DEFAULT” category 선언이 반드시 포함되어 있어야 한다. Data testURI 구조 및 Data type(MIME type)에 대해 나타내는데, URI의 각 부분에 대해서는 별도의 속성 (scheme, host, port, path)이 사용될 수 있다. &lt;intent-filter&gt; &lt;data android:mimeType=\"video/mpeg\" android:scheme=\"http\" ... /&gt; &lt;data android:mimeType=\"audio/mpeg\" android:scheme=\"http\" ... /&gt; ...&lt;/intent-filter&gt; content://com.example.project:200/folder/subfolder/etc scheme: content host: com.example.project port: 200 path: folder/subfolder/etc 위의 네 가지 속성에는 linear한 종속 관계가 존재한다. scheme이 지정되지 않으면 host를 무시한다. host가 지정되지 않으면 port를 무시한다. scheme과 host 둘 다 지정되지 않으면 path를 무시한다. Intent의 URI이 Filter의 URI와 비교될 때에는 filter 내에 포함된 URI와 부분적으로 비교된다. filter가 scheme만 지정한 경우, 해당 scheme을 가지는 모든 URI는 filter와 매칭된다. filter가 scheme과 authority를 지정하고 path를 지정하지 않는 경우, 같은 scheme과 authority를 갖는 모든 URI는 path와 관계 없이 filter를 통과한다. filter가 scheme, authority, path를 모두 지정할 경우, 같은 scheme, authority, path를 가진 URI만이 filter를 통과할 수 있다. path에는 * 을 사용할 수 있다. Data의 유효성을 판별하기 위해서는 intent의 URI, MIME type과 filter의 URI, MIME type을 모두 비교해야 한다. a. URI와 MIME type을 모두 갖지 않는 intent는 URI와 MIME type을 아무 것도 정의하지 않은 filter만을 통과할 수 있다. b. URI를 갖고 MIME type을 갖지 않는 intent는 filter의 URI와 일치하고 filter가 MIME type을 지정하지 않은 경우 통과할 수 있다. c. URI가 없고 MIME type만 갖는 intent는 filter가 URI를 지정하지 않고 MIME type을 가지고 있을 때 통과할 수 있다. d. URI와 MIME type을 모두 갖는 intent는 filter에 나열된 type과 매치되는 경우에만 통과한다. Intent의 URI가 filter의 URI와 일치하거나 content: 또는 file:을 가지고 있는 경우, 그리고 filter가 URI를 정의하지 않는 경우 통과할 수 있다. 다른 말로, filter가 MIME type만 가지고 있을 경우 component는 content:와 file:을 당연히 지원하는 것으로 여겨진다. 규칙 d는 component가 file 또는 content provider로부터 local file을 가지고 올 수 있다는 기대를 가지고 반영된다. 따라서, 이러한 filter는 data type만 나열해도 되고 content:와 file: scheme을 명시적으로 작성하지 않아도 된다. 아래 예시는 Content provider로부터 image data를 가지고 와서 표시할 수 있다는 의미를 갖는다. &lt;intent-filter&gt; &lt;data android:mimeType=\"image/*\" /&gt; ...&lt;/intent-filter&gt; 아래 예시는 Network에서 Video data를 검색할 수 있다는 의미를 갖는다. &lt;intent-filter&gt; &lt;data android:scheme=\"http\" android:type=\"video/*\" /&gt; ...&lt;/intent-filter&gt; Intent matching Intent를 Intent filter와 비교를 해보면 target component를 활성화 시킬 수 있을 뿐만 아니라 단말의 component set에 대한 정보를 발견할 수 있다. 예를 들어, Home application이 application 런쳐를 채우기 위해 ACTION_MAIN action과 CATEGORY_LAUNCH category를 갖는 intent filter들을 찾아볼 수 있다. 개발한 application에서 비슷한 방법을 사용할 수 있는데, Packagemanager는 query...() 메소드들을 가지고 있고 이는 특정 intent로 접근할 수 있는 모든 component를 return한다. 이와 비슷한 것들로 resolve...() 메소드들이 있다. 이는 intent를 응답하기 위한 최적의 component를 정의한다. 예를 들어, queryIntentActivities()는 intent가 argument로써 통과할 수 있는 모든 activity의 list를 return하고, queryIntentServices()는 service에 대한 list를 return한다. 두 가지 메소드 모두 component를 활성화 시키지는 않고 단지 list만 나열할 뿐이다. BroadcastReceiver에서 사용하는 것은 queryBroadcastReceivers()가 있다. 출처 https://developer.android.com/guide/components/fundamentals.html https://developer.android.com/reference/android/content/Intent.html https://developer.android.com/guide/components/intents-filters.html https://developer.android.com/guide/components/tasks-and-back-stack.html https://developer.android.com/reference/android/app/PendingIntent.html","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"android","slug":"Dev/android","permalink":"http://lazyrodi.github.io/categories/Dev/android/"}],"tags":[{"name":"android, intent","slug":"android-intent","permalink":"http://lazyrodi.github.io/tags/android-intent/"}]},{"title":"Singleton","slug":"2016-07-16-pattern-singleton","date":"2016-07-16T09:42:50.000Z","updated":"2016-07-16T12:34:14.609Z","comments":true,"path":"2016/07/16/2016-07-16-pattern-singleton/","link":"","permalink":"http://lazyrodi.github.io/2016/07/16/2016-07-16-pattern-singleton/","excerpt":"","text":"Singleton은 유일한 Instance를 만들어 사용하는 방법이다. 생성자를 private으로 하여 다른 곳에서 Instance를 직접 생성할 수 없으며, public getInstance()를 통해서만 instance를 가져가서 사용할 수 있다. 객체 = Object = Compile된 각각의 .class file 개체 = Instance = Compile된 .class file을 new 연산자를 사용하여 Memory에 Loading한 상태 기본적으로는 이런 느낌이다. 123456789101112131415public class Iamsingle &#123; private static Iamsingle mInstance; private Iamsingle() &#123; &#125; public static Iamsingle getInstance() &#123; if (mInstance == null) &#123; mInstance = new Iamsingle(); // 누군가가 만들어둔 Instance가 없다면 만들어서 돌려줍시다. &#125; return mInstance; &#125;&#125; 필요성설정 파일 등 여러 개가 있으면 혼란스러울 수 있는 경우 Singleton을 통해 하나의 자원만 사용할 수 있게 한다. 전역적으로 접근이 가능해야 하지만 단 하나만 있어야 한다. 전역 변수는 여러 개가 생성될 수 있기 때문에 Singleton을 사용하는 것이다. 싱글턴 패턴은 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴입니다. - Head First Design Patterns 또한, Global Class는 어플리케이션이 시작될 때 항상 로딩되지만 Singleton Class는 시작되는 지점을 개발자가 지정할 수 있다. Trouble shootingMultiThreading 문제 해결위쪽에서 표현한 코드는 MultiThread 환경에서 추가적인 Instance의 생성을 완전히 방어할 수 없다. 고로, Thread 사용 시 기본적인 방어 방법인 Syncronized를 붙여보기로 한다. 123456789101112131415public class Iamsingle &#123; private static Iamsingle mInstance; private Iamsingle() &#123; &#125; public static synchronized Iamsingle getInstance() &#123; if (mInstance == null) &#123; mInstance = new Iamsingle(); // 누군가가 만들어둔 Instance가 없다면 만들어서 돌려줍시다. &#125; return mInstance; &#125;&#125; Synchronized로 인한 성능 문제 해결Synchronized로 인한 MultiThreading 시의 성능은 엄청나게 떨어진다. 고로, Instance를 미리 생성해 보도록 한다. 1234567891011public class Iamsingle &#123; private static Iamsingle mInstance = new Iamsingle(); private Iamsingle() &#123; &#125; public static synchronized Iamsingle getInstance() &#123; return mInstance; &#125;&#125; 문제를 해결하는 또 다른 방법DCL (Double-Checking Locking) 이라는 방법으로 Instance가 생성되었으면 그냥 넘기고, 없는 경우에만 synchronized 를 걸어주어 Instance를 요청하는 Thread들에 부담을 덜어주는 방법이다. volatile keyword는 Java 코드의 변수(Variable)를 메모리에 저장(Store) 하라는 의미이다. volatile 변수는 CPU cache를 사용하지 않고 Main memory에 직접 read/write 한다. volatile에 대한 자세한 내용은 여기를 참조해 보자. 결론적으로 여기서는 CPU Cache를 통할 때 변수의 무결성을 보장할 수 없으므로 volatile을 통해 Main memory에 직접 접근하겠다는 뜻이다. 1234567891011121314151617181920public class Iamsingle &#123; private volatile static Iamsingle mInstance; private Iamsingle() &#123; &#125; public static Iamsingle getInstance() &#123; if (mInstance == null) &#123; // 여기까지는 MultiThread 방어가 되지 않은 상태. synchronized(this) &#123; if (mInstance == null) &#123; // 위의 첫 번째 null check를 통과한 thread가 대기하고 있다가 들어왔을 확률이 있기 때문에 한 번 더 check. mInstance = new Iamsingle(); &#125; &#125; &#125; return mInstance; &#125;&#125; 마무리 무분별하게 리팩토링 하겠다고 Singleton 남발하지 말 것. 전역 설정이 필요할 때 등 꼭 필요할 때만 사용할 것. 위에서 나열한 방법들 중 해당 어플리케이션에 적절한 것을 사용할 것. 단일 Thread를 사용하는 프로그램에서 굳이 synchronized로 성능 저하를 시킬 필요는 없다. 출처 http://noesse.tistory.com/28 Head First Design Patterns - 한빛미디어, O’Reilly.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"pattern","slug":"Dev/pattern","permalink":"http://lazyrodi.github.io/categories/Dev/pattern/"}],"tags":[{"name":"java, pattern, singleton","slug":"java-pattern-singleton","permalink":"http://lazyrodi.github.io/tags/java-pattern-singleton/"}]},{"title":"[Reference] My Favorite Colors","slug":"2016-07-16-works-my-favorite-colors","date":"2016-07-16T08:20:00.000Z","updated":"2016-07-16T12:38:03.200Z","comments":true,"path":"2016/07/16/2016-07-16-works-my-favorite-colors/","link":"","permalink":"http://lazyrodi.github.io/2016/07/16/2016-07-16-works-my-favorite-colors/","excerpt":"","text":"Color reference that I like. Link : http://lazyrodi.github.io/misc/MyFavoriteColors.html","categories":[{"name":"works","slug":"works","permalink":"http://lazyrodi.github.io/categories/works/"}],"tags":[{"name":"ui, design, color","slug":"ui-design-color","permalink":"http://lazyrodi.github.io/tags/ui-design-color/"}]},{"title":"Java Thread","slug":"2016-07-13-java-thread","date":"2016-07-13T11:42:50.000Z","updated":"2016-07-14T15:27:42.059Z","comments":true,"path":"2016/07/13/2016-07-13-java-thread/","link":"","permalink":"http://lazyrodi.github.io/2016/07/13/2016-07-13-java-thread/","excerpt":"","text":"Thread란 프로그램 실행 시 프로세스 내부에 존재하는 수행 단위를 말한다. Java에서는 두 가지의 Thread의 구현 방법이 있다. Thread를 상속받아서 사용하는 방법 이 경우 다른 Class의 상속이 불가능하다. Runnable interface를 구현하는 방법 일반적인 방법이다. 다른 Class의 상속이 가능하다. Thread 생성Thread 는 상태 변환을 통해 아래 그림과 같은 Lifecycle을 갖는다. 동작상태설명객체 생성NEWThread 객체의 생성 / start() 호출 전실행 대기RUNNABLE실행 상태로 언제든 갈 수 있는 상태일시정지WAITING다른 Thread가 통지할 때까지 기다리는 상태TIMES_WAITING주어진 시간동안 기다리는 상태BLOCKED사용하고자 하는 객체의 Lock이 해제될 때까지 기다리는 상태종료TERMINATED실행을 마친 상태 Thread를 상속받아 사용하는 방법 Thread로 수행될 Task class를 생성한다. 123456789101112public class Task extends Thread &#123; String mName; Task(String str) &#123; mName = str; &#125; public void run() &#123; // Thread 시작 시 수행된다. System.out.println(\"run \" + mName); &#125;&#125; Thread를 만들어 실행한다. start()가 호출되면 새로운 Thread가 작업을 실행하는데 필요한 Call Stack을 생성하고 run()을 호출하여 Stack에 저장한다. run() 메소드는 Thread scheduler에게 전달된다. 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Task tA = new Task(\"a\"); Task tB = new Task(\"b\"); Task tC = new Task(\"c\"); tA.start(); // start()를 호출하면 앞에서 만든 Task의 run()이 실행된다. tB.start(); tC.start(); &#125;&#125; Runnable interface를 구현하여 사용하는 방법 Thread로 돌아갈 class를 생성한다. 123456789101112public class Task implements Runnable &#123; String mName; Task(String str) &#123; mName = str; &#125; public void run() &#123; System.out.println(\"run \" + mName); &#125;&#125; 새 Thread 객체를 생성하여 start() 한다. run() 으로 실행하면 단순히 Task 객체의 run() 메소드가 수행되는 것 뿐이다. start()로 해야 별도의 Thread가 생성되어 수행된다. Thread가 제대로 생성되어 수행되는지는 Eclipse의 debug 모드 등에서 threadStatus 등 thread 관련 항목들이 제대로 수행되는지 확인한다. 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Task tA = new Task(\"a\"); Task tB = new Task(\"b\"); Thread t1 = new Thread(tA); Thread t2 = new Thread(tB); Thread t3 = new Thread(new Task(\"c\")); t1.start(); t2.start(); t3.start(); &#125;&#125; 아래와 같이 구현도 가능하다.123456789101112public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(new Runnable() &#123; public void run() &#123; System.out.println(\"run\"); &#125; &#125;); t.start(); &#125;&#125; join()Thread의 수행 시간이 오래 걸릴 때, Thread보다 Main 함수가 먼저 종료되는 경우가 있다. 이런 경우 join() 메소드를 사용하면 모든 Thread들이 종료된 후 Main 함수가 종료된다. 예를 들어, 아래 코드를 실행한 결과를 보면 fin이 먼저 호출되는 것을 볼 수 있다. 123456789101112131415161718192021222324252627282930public class Main &#123; public static void main(String[] args) &#123; Task tA = new Task(\"a\"); Task tB = new Task(\"b\"); Thread t1 = new Thread(tA); Thread t2 = new Thread(tB); Thread t3 = new Thread(new Task(\"c\")); Thread t4 = new Thread(new Task(\"d\")); Thread t5 = new Thread(new Task(\"e\")); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); System.out.println(\"fin\"); &#125; &#125;// 결과run arun cfinrun drun erun b 다음과 같이 join()을 사용할 경우, Thread들이 모두 실행된 이후에 fin이 찍힌다. 123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) &#123; Task tA = new Task(\"a\"); Task tB = new Task(\"b\"); Thread t1 = new Thread(tA); Thread t2 = new Thread(tB); Thread t3 = new Thread(new Task(\"c\")); Thread t4 = new Thread(new Task(\"d\")); Thread t5 = new Thread(new Task(\"e\")); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); try &#123; t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"fin\"); &#125; &#125;// 결과run arun drun erun brun cfin SynchronizedThread가 함수를 통해 전역변수에 변형을 가할 경우, 각 Thread가 돌면서 값이 잘못 변하는 경우가 있다. 만약 아래와 같은 코드가 있다고 하면 (여기서는 10개지만 더 많이…) 마지막에 결과값이 10이 안 찍히고 9가 찍히는 것을 볼 수 있다. 물론 실행할 때마다 값이 다르다. 내가 만들어서 그런지 예시가 거지같다. 12345678910111213141516171819202122232425public class Task implements Runnable &#123; String mName; static int no = 0; Task(String str) &#123; mName = str; &#125; public static void inc() &#123; no++; &#125; public void run() &#123; try &#123; Thread.sleep(1000); inc(); &#125; catch(Exception e) &#123; &#125; System.out.println(\"run \" + mName); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Main &#123; public static void main(String[] args) &#123; Task tA = new Task(\"a\"); Task tB = new Task(\"b\"); Thread t1 = new Thread(tA); Thread t2 = new Thread(tB); Thread t3 = new Thread(new Task(\"c\")); Thread t4 = new Thread(new Task(\"d\")); Thread t5 = new Thread(new Task(\"e\")); Thread t6 = new Thread(new Task(\"f\")); Thread t7 = new Thread(new Task(\"g\")); Thread t8 = new Thread(new Task(\"h\")); Thread t9 = new Thread(new Task(\"i\")); Thread t10 = new Thread(new Task(\"j\")); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); t6.start(); t7.start(); t8.start(); t9.start(); t10.start(); try &#123; t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); t6.join(); t7.join(); t8.join(); t9.join(); t10.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(tA.no); System.out.println(\"fin\"); &#125;&#125;// 결과run a no: 0run d no: 7run c no: 0run i no: 6run j no: 5run e no: 3run f no: 4run g no: 2run b no: 1run h no: 89fin 위의 문제가 발생하는 이유는 예를 들면 하나의 Thread가 no를 3에서 4로 증가시키고 있을 때 다른 Thread가 접근하고, 그 Thread도 3에서 4로 증가시키게 된다. 그러면 inc()가 두 번 수행되었더라도 no는 4에 머물러있게 된다. 이러한 문제를 방지하기 위해 no++ 과정을 synchronized(동기화) 시켜주면 된다. 하나의 Thread가 synchronized 키워드 안의 내용을 수행 중이라면 다른 Thread는 그 자원에 접근할 수 없게 된다. 12345678910111213141516171819202122232425public class Task implements Runnable &#123; String mName; static int no = 0; Task(String str) &#123; mName = str; &#125; synchronized public static void inc() &#123; no++; &#125; public void run() &#123; try &#123; Thread.sleep(1000); inc(); &#125; catch(Exception e) &#123; &#125; System.out.println(\"run \" + mName); &#125;&#125; Thread PoolThread를 생성하기 위해서는 시간과 메모리가 소요된다. Java는 JVM(Java Virtual Machine) 위에서 돌아가고 JVM은 Thread의 생성 개수를 제한하지 않는다. 때문에 Thread를 과도하게 생성한다면 성능 저하는 물론 Memory leak이 발생한다. Thread의 무분별한 생성을 막기 위해 쓰레드 관리 방식인 Thread Pool을 사용한다. Thread Pool은 Thread를 허용된 개수 안에서 사용할 수 있도록 제약한다. 이 제약은 JVM이 하는 것이 아니라 어플리케이션에서 해야 한다. JDK 1.5 이전에는 개발자가 직접 만들어서 사용했으며, 1.5부터 java.util.concurrent 를 통해 지원하게 되었다. Excutors.newFixedThreadPool(n) 최대 Thread 수가 n 개인 Pool. 동시에 일어나는 업무량이 비교적 일정할 때 사용한다. Excutors.newCachedThreadPool() Thread 수의 제한을 두지 않는다. 새로운 Thread 시작 요청이 들어올 때마다 Thread를 하나씩 생성한다. 수행이 종료된 Thread들이 바로 사라지지 않고 1분동안 살아있다가 다른 작업 요청이 없다면 사라지게 된다. 짧고 반복되는 작업에 사용한다. Executors.newSingleThreadExecutor() 하나의 Thread를 생성한다. 주로 Thread 작업 중 예외가 발생한 경우 예외 처리를 위한 Thread 생성 용으로 사용한다. 선언은 ExecutorService 로 한다. Excutors.newFixedThreadPool(n)123456789ExecutorService executorService = Executors.newFixedThreadPool(2);// Thread 생성 요청.// Task는 수행할 class 명.// 세 번 요청하면 세 번째 Thread는 앞의 두 개 중 하나가 종료될 때까지 수행되지 않는다.executorService.execute(new Task(\"name\"));executorService.shutdown(); // 추가적인 Thread 요청을 거부한다.while (!executorService.isTreminated()) &#123; // 모든 Thread가 완료될 때까지 대기한다.&#125; Excutors.newCachedThreadPool()123456ExecutorService executorService = Executor.newCachedThreadPool();executorService.execute(new Task(\"name\"));executorService.shutdown();while (!executorService.isTreminated()) &#123;&#125; Executors.newSingleThreadExecutor()123456789101112131415ExecutorService executorService = Executors.newSingleThreadExecutor();executorService.execute(()-&gt;&#123; try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; &#125;; &#125;&#125;);executorService.shutdown();while (!executorService.isTreminated()) &#123;&#125; 출처 http://blog.naver.com/2feelus/220728222140 http://blog.naver.com/kksssii/220676622695","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"java","slug":"Dev/java","permalink":"http://lazyrodi.github.io/categories/Dev/java/"}],"tags":[{"name":"java, thread","slug":"java-thread","permalink":"http://lazyrodi.github.io/tags/java-thread/"}]},{"title":"Hexo로 변경","slug":"2016-07-11-life-change-to-hexo","date":"2016-07-11T13:00:00.000Z","updated":"2016-07-11T14:04:00.129Z","comments":true,"path":"2016/07/11/2016-07-11-life-change-to-hexo/","link":"","permalink":"http://lazyrodi.github.io/2016/07/11/2016-07-11-life-change-to-hexo/","excerpt":"","text":"원래 사용하던 Jekyll에서 Hexo로 변경하였다. 이 테마(hueman)가 상당히 완성도가 높아보여서 따라하느라 변경하였는데 Jekyll보다 지원하는 기능이 화려하다. (혹은 내가 Jekyll도 제대로 못 썼겠지.) 맘에 든다. 설명도 꽤 간단하고 알아먹기 쉽게 제공되어서 좋다. Jekyll에서 가져온 글들이 markdown간 호환이 100% 되지는 않아서 테이블과 그림 작업이 더 필요하지만… 그래도 뭐 굳.","categories":[{"name":"life","slug":"life","permalink":"http://lazyrodi.github.io/categories/life/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://lazyrodi.github.io/tags/hexo/"}]},{"title":"Android permission","slug":"2016-07-10-android-permission","date":"2016-07-10T10:47:50.000Z","updated":"2016-07-11T13:54:04.502Z","comments":true,"path":"2016/07/10/2016-07-10-android-permission/","link":"","permalink":"http://lazyrodi.github.io/2016/07/10/2016-07-10-android-permission/","excerpt":"","text":"안드로이드는 privilege-separated OS이다. 각각의 어플리케이션들은 서로 다른 system ID(Linux의 User ID 또는 Group ID)로 구분된다. 안드로이드 시스템의 보안 기능은 세분화 되어있으며 Permission Mechanism에 의해 동작한다. 안드로이드 시스템은 시스템 자체의 무결성(Integrity)과 개인 정보 보호를 위해 각 어플리케이션이 sandbox(보호된 영역) 내에서만 동작하도록 제한해 두었다. 어플리케이션이 자신의 sandbox 밖의 리소스, 파일 등의 사용을 원할 때에는 명시적으로 해당 permission에 대해 요청하고 획득해야 한다. Permission은 특정 프로세스가 특정 기능을 수행하기 위해 필요한 권한을 의미하며, 사용자가 허가를 해야 사용할 수 있다. 안드로이드의 System permission은 두 가지 종류로 나눌 수 있다. (Normal and Dangerous Permissions 참조) Normal permissions 다른 프로세스, 데이터, 사용자에게 악영향을 주지 못하는 권한들. Dangerous permissions 파일 저장 및 운용, 주소록 접근 등 다른 요소에 악영향을 줄 수도 있는 권한들. 안드로이드 시스템은 어플리케이션이 Normal permissions을 요청하면 자동으로 권한을 부여하고, Dangerous permissions를 요청하면 사용자에게 Dialog를 통해 확인(Dangerous permissions)을 받은 후 허가를 해준다. 사용자에게 확인을 받는 동작은 안드로이드 버전에 따라 다르게 동작한다. Android 5.1 (Lollipop) 이하 어플리케이션 설치 시 사용할 permission들에 대해 사용자의 허가를 받음. Android 6.0 (Marshmallow) 이상 Runtime에 permission을 부여할지 묻는다. System PermissionsSecurity architecture안드로이드는 기본적으로 Permission이 없으면 하나의 어플리케이션이 다른 어플리케이션, OS, user에게 위해를 가할 수 없다. 예를 들어, permission 없이는 주소록이나 이메일 등의 접근할 수 없고 다른 어플리케이션에 속한 파일에 접근할 수 없다는 뜻이다. 어플리케이션은 필요로 하는 permission에 대해 Application Manifest 파일에 static하게 선언해야 한다. &lt;uses-permission&gt; 태그를 이용하며, 아래의 예시는 SMS의 발신 권한을 획득하기 위한 선언이다. 1234567891011&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.snazzyapp\"&gt; &lt;uses-permission android:name=\"android.permission.SEND_SMS\"/&gt; &lt;application ...&gt; ... &lt;/application&gt;&lt;/manifest&gt; 어플리케이션 Sandbox는 어플리케이션이 어떻게 빌드 되었던 간에 독립적으로 동작하며 어플리케이션의 형태(Java, native, hybrid)에 관련 없이 같은 방식, 같은 강도의 보안을 가지고 있다. Permission의 요청이 실패할 경우 SecurityException을 return받게 된다. 하지만 요청이 실패한다고 해서 반드시 이 exception이 발생하는 것은 아니다. 예를 들어, sendBroadcast(Intent) 메소드는 각각의 receiver로 전달되는 데이터에 대해 permission check를 진행하지만 값이 return될 때 permission failure가 발생했었는지 여부는 알 수 없게 된다. 그래도 대부분 permission failure에 대한 정보는 system log에 남기 때문에 이상 여부를 확인할 수 있다. 사용 가능한 Permission의 종류는 Manifest.permission에서 확인할 수 있다. 아래와 같은 특정한 상황에서는 어플리케이션 동작 중에 별도의 permission을 요구하게 된다. 시스템에 대한 호출 시 어플리케이션이 특정 기능을 무단으로 사용하는 것을 방지하기 위해 Activity가 시작될 때 다른 어플리케이션의 activity가 임의로 시작되는 것을 막기 위해 Broadcast의 전송/수신 시 내가 보낸 Broadcast를 누가 받았는지, 누가 나에게 Broadcast를 보냈는지 제어하기 위해 Content provider에 접근 시 Service를 시작하거나 Binding 할 때 Application Signing모든 APK들은 개발자의 private key을 이용한 인증과정을 통해 서명된 상태여야 한다. 서명은 특별히 인증기관 등의 허가를 받는 것은 아니며, 개발자 스스로 생성한 key로 서명할 수 있다. 서명의 목적은 제작자가 누구인지 구분하는 것이다. (복제 방지, 악용 방지) 서명을 통해 시스템은 어플리케이션이 signature-level permissions (normal, dangerous, signature, signatureOrSystem)에 접근할 수 있는 권한을 부여/거부한다. 어플리케이션이 다른 어플리케이션과 동일한 Linux ID를 사용하려 할 때에도 서명 정보를 필요로 한다. User ID와 File access어플리케이션 설치 시 안드로이드는 각각의 package에 각각 다른 Linux user ID를 부여한다. 이는 상수값이며 해당 package가 죽을 때까지 가지고 있는다. 보안 권한은 Process level에 존재하고, 일반적으로 서로 다른 두 개의 package가 하나의 process에서 수행되는 일은 없다. 보통 서로 다른 Linux user로 동작한다. 하지만 AndroidManifest.xml의 manifest tag 내에 sharedUserId 속성을 사용하게 되면 서로 다른 package들이 같은 user ID를 사용할 수도 있다. 이 방법을 통해, 보안을 목적으로 하는 두 개의 package가 하나의 어플리케이션인척 행동하게 된다. 이 때 user ID 및 file에 대한 권한을 동일하게 갖는다. 보안을 유지하기 위해 동일한 서명을 사용한 어플리케이션 중 단 두 개의 어플리케이션만 동일한 user ID를 사용할 수 있다. 어플리케이션이 저장한 data들은 해당 어플리케이션의 user ID에 할당되며, 기본적으로 다른 package에서는 접근이 불가하다. 어플리케이션이 새로 만들거나 저장하는 파일들에 대한 메소드는 다음과 같다. getSharedPreferences(String, int) openFileOutput(String, int) openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory) 만약 다른 package들이 read/write를 할 수 있게 하려면 MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE flag를 사용해야 한다. 이 flag들을 사용하여도 소유권은 변하지 않는다. Automatic permission adjustments시간이 지나면서(새로운 sdk가 나오면) 이전에는 없던 permission이 만들어지기도 한다. 해당 permission이 만들어지기 전에 생성된 어플리케이션은 당연히 권한 없이도 이를 사용할 수 있다는 가정 하에 개발되었기 때문에 관련 기능을 사용하려면 에러가 날 수도 있다. 에러를 방지하기 위해 안드로이드는 Manifest에 새 permission에 대한 코드를 추가한다. 추가할지 말지 결정하는 근거가 되는 것이 targetSdkVersion 이며, 이 값이 permission이 생성된 버전보다 낮다면 안드로이드는 permission을 추가한다. 예를 들어, WRITE_EXTERNAL_STORAGE permission은 공유된 저장소에 접근하는 것을 제한하기 위해 API level 4에 만들어졌다. 만약 targetSdkVersion이 3보다 낮다면 이 permission은 자동으로 추가된다. 만약 이 경우처럼 자동으로 permission이 추가되는 경우, Google Play에서 이러한 권한들에 대해 보여주게 된다. (실제로 그 어플리케이션에서 사용하지 않더라도 보여준다.) 사용하지 않는 permission을 제거하기 위해서는 어플리케이션의 targetSdkVersion을 항상 최신화하여 유지하는 것이 좋다. Build.VERSION_CODES를 통해 각 버전 별로 업데이트 된 permission 목록을 확인할 수 있다. Permission groups모든 dangerous Android system permission은 permission group에 속해있다. Permission이 같은 group에 속한 경우 사용자에게 한 번만 사용 허가를 받으면 같은 group에 속한 다른 permission들도 사용할 수 있다. 예를 들어, READ_CONTACTS에 대한 권한을 사용자로부터 허가받아 부여받았다면, WRITE_CONTACTS 권한은 자동으로 부여받는다. [표 1. Dangerous permissions and permission groups] |————-+——————————|| CALENDAR | READ_CALENDAR || | WRITE_CALENDAR || CAMERA | CAMERA || CONTACTS | READ_CONTACTS || | WRITE_CONTACTS || | GET_ACCOUNTS || LOCATION | ACCESS_FINE_LOCATION || | ACCESS_COARSE_LOCATION || MICROPHONE | RECORD_AUDIO || PHONE | READ_PHONE_STATE || | CALL_PHONE || | READ_CALL_LOG || | WRITE_CALL_LOG || | ADD_VOICEMAIL || | USE_SIP || | PROCESS_OUTGOING_CALLS || SENSORS | BODY_SENSORS || SMS | SEND_SMS || | RECEIVE_SMS || | READ_SMS || | RECEIVE_WAP_PUSH || | RECEIVE_MMS || STORAGE | READ_EXTERNAL_STORAGE || | WRITE_EXTERNAL_STORAGE | Permission의 정의 및 제한Permission을 적용하기 위해서는 AndroidManifest.xml에 &lt;permission&gt; 태그를 사용하여 정의해야 한다. 아래의 예시는 어플리케이션이 자신이 가진 activity 중 하나를 시작하는 권한을 다른 어플리케이션에게 부여하기 위해 permission을 선언한 것이다. 123456789&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.myapp\" &gt; &lt;permission android:name=\"com.example.myapp.permission.DEADLY_ACTIVITY\" android:label=\"@string/permlab_deadlyActivity\" android:description=\"@string/permdesc_deadlyActivity\" android:permissionGroup=\"android.permission-group.COST_MONEY\" android:protectionLevel=\"dangerous\" /&gt; ...&lt;/manifest&gt; 참고로 모든 package가 동일한 인증서로 서명하지 않은 한, 여러 package가 동일한 이름의 permission을 선언할 수는 없다. 하나의 Package가 permission을 선언한 경우 시스템은 같은 permission 이름을 가진 다른 package가 시스템에 설치되는 것을 막는다. 물론 이미 설치되어 있는 package와 동일한 서명을 가지고 있다면 설치를 허가한다. 이런 충돌을 피하기 위해 안드로이드에서는 reverse-domain-style naming을 추천한다. ex. com.example.myapp.ENGAGE_HYPERSPACE 위의 예시에서 하나하나 살펴보면; protectionLevel Mandatory 항목이다. 시스템이 어플리케이션이 이 권한을 필요로 하는 이유 또는 이 권한을 가지고 있는 것들이 무엇인지 사용자에게 알려주기 위한 속성이다. 아래 AndroidManifestPermission_protectionLevel 을 살펴보자. android:permissionGroup Optional 항목이다. 시스템이 권한에 대해 사용자에게 보여줄 때에만 사용된다. 대부분의 경우, standard system group(android.Manifest.permission_group)으로 설정하게 된다. CALENDAR CAMERA CONTACTS LOCATION MICROPHONE PHONE SENSORS SMS STORAGE 개발자가 직접 정의할 수도 있다. 하지만 왠만하면 기존에 있는 것으로 사용하자. 안드로이드 폰에서 설정 &gt; 앱 &gt; 앱 설정 &gt; 앱 권한 으로 가면 permissionGroup으로 묶여있는 것을 확인할 수 있다. android:label android:description label 및 description은 사용자가 permission list 확인 시 보여줄 제목 및 상세 내용이다. 새로 추가해야 한다면 가능한 짧게 작성하라. 아래는 CALL_PHONE permission에 대한 label 및 description 예시이다. $ adb shell pm list permissions 명령어를 통해 현지 시스템에서 사용하고 있는 권한들을 확인할 수 있다. 12345&lt;string name=\"permlab_callPhone\"&gt;directly call phone numbers&lt;/string&gt;&lt;string name=\"permdesc_callPhone\"&gt;Allows the application to call phone numbers without your intervention. Malicious applications may cause unexpected calls on your phone bill. Note that this does not allow the application to call emergency numbers.&lt;/string&gt; AndroidManifestPermission_protectionLevel|———————–+——————-+———————|| Constant | Value | Description || normal | 0 | 낮은 위험도를 가진 permission. 어플리케이션이 다른 어플리케이션에 별다른 영향을 주지 않는 부분으로 접근을 시도한다. 시스템은 이 권한을 요청하는 어플리케이션에게 권한을 자동적으로 부여한다. || dangerous | 1 | 높은 위험도를 가진 permission. 어플리케이션이 개인 정보 및 디바이스를 나쁜 목적으로 사용이 가능하다. 시스템은 이 권한을 자동으로 부여하지 않고 사용자에게 허가를 요구하는 dialog 를 띄워서 허가를 받는다. || signature | 2 | 같은 인증서로 서명된 어플리케이션에게만 이 권한을 허가한다. 인증서가 동일한 것이 판명되면 시스템은 자동적으로 권한을 부여한다. || signatureOrSystem | 3 | 안드로이드 시스템 이미지 내의 package 또는 같은 인증서로 서명된 어플리케이션에게만 권한을 허가한다. 이 옵션은 피해야 하며, Signature protection level은 대부분의 요구를 충족시켜야 하고 어플리케이션이 어디에 설치되었건 정확하게 동작해야 한다. || privileged | 0x10 | base permission type으로부터 파생된 추가적인 flag로 이 permission은 시스템 이미지에 설치된 privileged app들에 부여될 수 있다. 이 옵션은 피해야 하며, Signature protection level은 대부분의 요구를 충족시켜야 하고 어플리케이션이 어디에 설치되었건 정확하게 동작해야 한다. || system | 0x10 | “privileged”와 동일하다. 이전에 사용하던 용어. || development | 0x20 | base permission type으로부터 파생된 추가적인 flag로 개발용 어플리케이션에 선택적으로 부여될 수 있다. || appop | 0x40 | base permission type으로부터 파생된 추가적인 flag로 제어 권한을 위한 app op과 밀접한 관련을 가지고 있음. || pre23 | 0x80 | base permission type으로부터 파생된 추가적인 flag로 Marshmallow 이전 버전의 API level을 갖는 어플리케이션들에게 자동으로 부여된다. (runtime permission 부여를 지원하지 않는 버전들) || installer | 0x100 | base permission type으로부터 파생된 추가적인 flag로 시스템 어플리케이션 권한을 가진 어플리케이션들에게 자동으로 부여된다. || verifier | 0x200 | base permission type으로부터 파생된 추가적인 flag로 시스템 어플리케이션 권한을 가진 어플리케이션들에게 자동으로 부여된다. || preinstalled | 0x400 | base permission type으로부터 파생된 추가적인 flag로 시스템 이미지 위에 미리 설치되는 어플리케이션들(privileged 어플리케이션을 포함한)에게 자동으로 부여된다. || setup | 0x800 | base permission type으로부터 파생된 추가적인 flag로 setup wizard 어플리케이션에게 자동으로 부여된다. | Custom permission, 이렇게 사용하라. 여러 어플리케이션을 묶어서 제품군을 설계할 때, 각각의 permission이 단 한번만 정의될 수 있도록 설계해야 한다. 서로 다른 어플리케이션이 같은 인증서로 서명한 경우 signature check를 통해 중복으로 permission을 정의하는 것을 막을 수 있다. 하나의 제품군을 개발하는 경우 이 모든 제품군의 permission을 관리하는 하나의 pacakage를 개발하는 것이 좋다. 이 package는 특별히 서비스를 제공하진 않고 permission을 관리할 뿐이며, 제품군에 속한 다른 어플리케이션들은 만 사용하게끔 한다. AndroidManifest.xml의 permission 제한개발자는 AndroidManifest.xml을 통해 시스템 또는 어플리케이션의 모든 컴포넌트에 접근 제한을 걸 수 있다. 이를 위해 컴포넌트 별로 android:permission 속성을 선언하고 해줘야 한다. Activity permissions () 관련된 activity를 실행할 수 있는 권한을 나타낸다. 이 permission은 Context.startActivity()와 Activity.startActivityForResult() 실행 시 체크된다. 만약 호출한 측이 permission을 가지지 않았다면 SecurityException이 발생한다. Service permissions () 관련된 service에 bind할 수 있는 권한을 나타낸다. 이 permission은 Context.startService(), Context.stopService(), Context.bindService() 실행 시 체크된다. 만약 호출한 측이 permission을 가지지 않았다면 SecurityException이 발생한다. BroadcastReceiver permissions () 관련된 receiver로 broadcast를 보낼 수 있는 권한을 나타낸다. Context.sendBroadcast()가 return될 때 permission 체크가 이루어지며, 시스템은 broadcast를 정해진 receiver로 전달하려 한다. Permission이 없는 경우 호출한 측으로 result가 제대로 전달되지 않고 exception이 전달된다. 이 Permission은 Context.registerReceiver를 통해 동적으로 등록할 수도 있다. 다른 방법으로 Context.sendBroadast() 호출 시 permission을 명시하여 broadcast를 수신할 수 있는 BroadcastReceiver를 제한할 수 있다. ContentProvider permissions () ContentProvider 내의 data에 접근하는 것을 제한할 수 있다(ContentProvider는 URI permission이라 불리는 중요한 추가 보안 기능을 가지고 있다.). 다른 컴포넌트들과는 다르게 두 개의 permission attribute를 설정할 수 있다. write 권한을 가지고 있다고 해도 read할 수 없다. android:readPermission android:writePermission 최초 provider를 찾을 때(retrieve) permission에 대해 체크하며 두 개의 permission 모두 없다면 SecurityException이 발생한다. ContentResolver.query()는 read permission을 요구하며, ContentResolver.insert(), ContentResolver.update(), ContentResolver.delete()는 write permission을 요구한다. Sending Broadcast 시의 Permission 제한BroadcastReceiver를 regist하는 것(Context.registerReceiver())에 더하여 broadcast를 보낼 때 필요한 permission을 지정할 수도 있다. Context.sendBroadcast() 호출 시 permission string을 포함하여 보내면 해당 permission을 가지고 있는 receiver만 수신할 수 있다. receiver와 broadcaster 모두 permission을 가지고 있어야 한다. Permission을 제한하는 다른 방법다른 프로세스가 현재 프로세스의 Service 등을 호출했을 때 Context.checkCallingPermission()을 사용할 수 있으며 return값인 PERMISSION_GRANTED, PERMISSION_DENIED 로 호출한 프로세스가 권한을 가지고 있는지 확인할 수 있다. Permission 체크를 위한 두 가지 방법이 더 있다. 다른 프로세스의 PID(Process Identifier)를 알고있다면 Context.checkPermission(String, int, int)를 사용할 수 있다. 다른 어플리케이션의 Package name을 알고있다면 PackageManager.checkPermission(String, String)을 사용할 수 있다. URI PermissionContent provider 사용 시 standard permission system에 기술된 내용은 충분하지 않다. Content provider는 직접적인 client는 물론 다른 어플리케이션이 동작하기 위한 특정한 URI를 다룰 때 read/write permission을 통해 스스로를 보호하기를 원한다. 대표적인 예로, Mail 어플리케이션에서의 파일 첨부 기능을 보자. Mail로의 접근은 user-data의 보호를 위해 permission으로 막혀있다. Image 첨부 기능의 URI가 Image viewer에 제공되어 있다 하더라도, Image viewer는 permission이 없기 때문에 첨부 파일을 열 수 없다. 이 문제의 해결책이 per-URI permission이다. Activity가 시작되거나 result가 activity로 return될 때 Caller는 Intent.FLAG_GRANT_READ_URI_PERMISSION 또는 Intent.FLAG_GRANT_WRITE_URI_PERMISSION을 설정할 수 있다. 이는 별도로 Content provider의 data 접근을 위한 permission을 가질 필요 없이 Intent 내의 특정 data URI를 통해 activity permission을 받겠다는 의미이다. 이 동작 방식은 파일 열기, 주소록 선택 등의 사용자와의 상호 작용 발생 시 임시로 권한을 허가하는, 일반적인 capability-style 모델을 가능케 한다. 또한, 어플리케이션이 쓸데없는 permission을 갖게지 않게하는데 핵심적인 역할을 한다. URI permission의 권한 부여을 위해 해당 URI들을 가지고 있는 Content provider는 자신이 이 기능을 구현하고 있다는 것을 알리기 위해 android:grantUriPermissions 속성을 선언하거나 &lt;grant-uri-permissions&gt; tag를 선언해야 한다. 아래와 같은 방식으로 Flag를 세팅할 수 있다. 123456startActivity( new Intent(Intent.ACTION_VIEW) .setDataAndType(uri, type) .addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) ); Permission 사용하기Permission 확인어플리케이션에서 Dangerous permission의 사용을 요청할 경우 사용할 때마다 permission을 얻은 상태인지 체크 해야하며, ContextCompat.checkSelfPermission() 메소드를 사용하면 된다. 아래는 캘린더 작성 permission에 대한 Android의 예시이다. Permission을 획득했다면 PackageManager.PERMISSION_GRANTED가 return될 것이며, permission이 없다면 PERMISSION_DENIED가 return될 것이다. 123// Assume thisActivity is the current activityint permissionCheck = ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR); Permission 요청하기사용자가 한 번 거부한 permission에 대해서는 설명을 추가(ex. Don’t ask again 체크박스)해야 하는데 한 번 거부한 permission인지 알 수 있는 방법은 shouldShowRequestPremissionRationale() 메소드를 사용하는 것이다. 만약 이전에 사용자가 DENY처리한 적이 있다면 true가 return된다. 어플리케이션이 permission을 아직 안 가지고 있을 경우 requestPremissions()를 호출해야 한다. 아래 코드는 READ_CONTACTS 기능에 대해 permission을 가지고 있는지 확인하며, permission이 없다면 요청한다. 1234567891011121314151617181920212223242526// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125; Permission request responsePermission을 사용자에게 요청 시 dialog box를 보여주게 된다. 사용자가 allow/deny를 입력하면 시스템은 어플리케이션의 onRequestPermissionsResult() 메소드를 호출한다. 어플리케이션에서 보낸 requestPermission()에 대해 동일한 request code가 도착하는지 확인하기 위해 callback 함수인 onRequestPermissionResult()를 override 해야한다. 아래 예시는 READ_CONTACTS 권한을 요청하고 callback 받는 것이다. 123456789101112131415161718192021222324@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other 'case' lines to check for other // permissions this app might request &#125;&#125; Permission 잘 사용하기Intent의 사용을 고려하라App에서 task를 수행하기 위한 방법은 크게 두 가지가 있다. App이 task를 스스로 수행하게 하는 것 Intent를 던져서 다른 어플리케이션이 task를 수행하게 하는 것 사진을 찍고 싶으면 CAMERA permission을 요청하여 카메라 제어와 관련된 모든 permission을 가지고 올 수 있다. 하지만 ACTION_IMAGE_CAPTURE intent를 날려서 사진을 찍을 수도 있다. 이 intent를 던지면 카메라 app을 설정하라는 dialog가 발생한다. 만약 default app으로 설정된게 있으면 안 뜬다. 사용자가 사진을 찍고 나면 onActivityResult()를 통해 사진을 callback받을 수 있다. 이 두 가지 방법은 이 세상 이치가 그렇듯 각각의 장단점이 있었으니… Permission 사용 시 App이 모든 제어권을 갖지만 그에 따른 모든 UI를 설계해야 하기 때문에 App이 복잡해진다. 한 번 permission을 받으면 계속 사용할 수 있지만 사용자가 permission 획득을 거부한다면 어플리케이션은 무용지물이 된다. Intent 사용 시 수행 동작들에 대한 UI를 구성할 필요가 없으며 intent를 처리하는 어플리케이션이 준비한 UI를 사용한다. 하지만 이는 곧 UX를 제공할 수 없다는 말이 된다. 사용자가 default app을 지정하지 않았다면 system은 app을 고르는 화면을 보여줄 것이다. 사용자가 default handler를 지정하지 않으면 동작이 수행될 때마다 dialog를 띄워줄 것이다. 꼭 필요한 permission만 요청하라Android 6.0 이상의 버전에서는 permission이 필요한 기능을 새로 수행할 때마다 사용자에게 수행할 것인지 묻는다. 사용자 입장에서 여러가지 기능에 대해 자꾸 물어보면 짜증나니까 꼭 필요한 permission만 사용하고 요청하도록 한다. 어플리케이션의 core가 되는 기능이 아니라면 왠만하면 intent를 던져서 사용하자. 쓸데없이 permission을 많이 가져가지 말아라한 번에 너무 많은 permission을 요청할 경우, 어플리케이션이 종료될 수도 있다. 어플리케이션 구동에 있어서 꼭 필요한 permission은 어플리케이션이 처음 실행될 때 획득할 수 있게 처리하는 것이 좋다. 예를 들어, 사진 어플리케이션이 처음 구동될 때 카메라 제어에 대한 permission을 받는 것이 좋지만 READ_CONTACTS등의 permission은 주소록을 통한 공유 등 그 기능이 처음 수행될 때 받는 것이 좋다는 이야기이다. 그 Permission이 왜 필요한지 사용자에게 설명하라requestPermissions()를 호출하면 permission dialog가 뜬다. 하지만 왜 이 permission을 획득해야 하는지는 알려주지 않는다. Permission을 요청하면 사용자는 왜 이 permission이 필요한지 궁금해진다. 예를 들어, 사진 어플리케이션이 geotag를 위해 location service를 필요로 할 때, 무턱대고 location permission을 요청하면 사용자들은 의아하게 생각한다. 따라서 requestPermissions()를 호출하기 전에 사용자에게 설명해줄 필요가 있다. 사용자에게 알려주는 방법 중 하나는 app tutorial을 넣는 것이다. Demo를 보여줌으로써 사용자가 이 permission이 왜 필요한지 느낄 수 있다. Permission에 대해 test하는 방법API level 23 이상의 단말에서는 아래 방법으로 permission과 관련된 문제 있는 코드를 확인할 수 있다. 어플리케이션의 현재 permission 및 관련 경로를 확인한다. Permission이 필요한 service를 수행하거나 data에 접근을 시도한다. 여러가지 permission을 얻었다 잃었다 하면서 테스트한다. 예를 들어, 카메라 어플리케이션은 CAMERA, READ_CONTACTS, ACCESS_FINE_LOCATION이 필요하다고 할 때, 이 세 가지를 껐다 켰다 하면서 테스트를 진행한다. ADB를 통해 다음 항목들을 시험해볼 수 있다. Permission list를 확인하는 방법12$ adb shell pm list permissions -d -g permission을 획득/제거하는 방법12$ adb shell pm [grant|revoke] &lt;permission-name&gt; ...","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"android","slug":"Dev/android","permalink":"http://lazyrodi.github.io/categories/Dev/android/"}],"tags":[{"name":"android, permission","slug":"android-permission","permalink":"http://lazyrodi.github.io/tags/android-permission/"}]},{"title":"OSI 7 layer and TCP/IP model","slug":"2016-07-04-osi7-and-tcpip","date":"2016-07-04T06:47:50.000Z","updated":"2016-07-18T15:21:41.708Z","comments":true,"path":"2016/07/04/2016-07-04-osi7-and-tcpip/","link":"","permalink":"http://lazyrodi.github.io/2016/07/04/2016-07-04-osi7-and-tcpip/","excerpt":"","text":"10년이 넘도록 외워지지 않는 Network 기초… OSI 7 layerOSI (Open System Interconnection) 7 Layer 는 Network Communication 시 발생하는 충돌들을 완화하기 위해 ISO에서 표준화된 Network 구조로 제시한 기본 모델이다. ISO/IEC 7498 Spec. ISO/IEC 7498-1: The Basic Model ISO 7498-2: Security Architecture ISO/IEC 7498-3: Naming and addressing ISO/IEC 7498-4: Management framework [7] 응용 계층 (Application) Application Software에 API 제공 Data type: Message Equipment: L7 ~ L5 Switch, Gateway (IP + TCP / UDP + Packet) Protocol: DNS, SNMP [6] 표현 계층 (Presentation) Network Security (번역기 역할) 암호화, 압축, 변환 Data type: Message Equipment: L7 ~ L5 Switch, Gateway (IP + TCP / UDP + Packet) Protocol: MPEG, JPG, MIME [5] 세션 계층 (Session) Socket Program 동기화, 통신 선로 구축 및 유지 Session 연결, 관리, 종료 Data type: Message Equipment: L7 ~ L5 Switch, Gateway (IP + TCP/UDP + Packet) Protocol: 전송 모드 결정 (반이중, 전이중, 직렬, 병렬, 동기, 비동기) RTP (Real-time Transport Protocol) [4] 전송 계층 (Transport) 데이터 전송 보장 흐름 제어 (정지 대기, 슬라이드) QoS (Quality of Service) Data type: Segment Equipment: L4 Switch (IP+TCP/UDP, Load balancing) Protocol: TCP, UDP [3] 네트워크 계층 (Network) 통신 경로 설정 (Routing): 중계 기능 담당, 교환 혼잡 제어 IPv4, IPv6 Data type: Packet Equipment: L3 Switch (IP 주소 참조), Router (유선, 무선) Protocol: IP, ARP, RARP, 회선 교환, 패킷 교환 [2] 데이터 링크 계층 (Datalink) 오류 제어, Frame 형식 정의 및 생성, MAC 제어 에러 검출 및 정정, 흐름 제어 Data type: Frame Equipment: L2 Switch MAC 주소 참조 Bridge (segment) Switch (frame) Protocol: FEC, ARQ, H-ARG, 해밍코드 [1] 물리 계층 (Physical) 물리적 연결 설정, 해제 Data 코딩, 변조 방식 (AM, FM, PM) Data 부호화 방식 (ASK, FSK, PSK) Multiplexing (TDM, FDM) Data 전송 속도 (bps, Baud) Data type: Bit stream Equipment: Repeater/Hub Protocol: 전기적 신호, 절차적 규격, 맨체스터 코드 OSI 7 Layer가 적용된 Protocol들에는 다음과 같은 것들이 있음. Bluetooth USB SATA PCI-E Zigbee Thunderbolt 인터넷에 떠다니는 그림인데 원래 출처를 모르겠습니다. 문제가 되면 삭제하겠습니다. TCP/IP위 그림에서 보듯 TCP/IP는 OSI 7 Layer 대신 4개의 Layer로 정의해 둔 것이다. Network를 상호 연결시켜 정보를 전송하는 기능을 가진 여러 개의 Protocol을 집합으로 묶어둔 것이 특징이다. TCP/IP 각각의 Protocol이 하는 기능은 다음과 같다. | 구분 | 기능 | Protocol | Description || 응용계층 | FTP | FTP | 파일 전송 프로토콜 || | | TFTP | 소형 파일 전송 Protocol || | E-mail | SMTP | 메일 서버 간의 메일 송수신 || | | POP3 | 메일 클라이언트와 메일 서버 간의 메일 송수신 || | | IMAP4 | POP3의 단점을 보완함 (원격 서버의 계층 구조를 유지한다.) || | Telnet | Telnet | 다른 시스템으로 로그인하는 기능 || | 인터넷 | HTTP | Web service protocol || | | SNMP | 데이터 흐름 정보 (네트워크 및 Host 상태 모니터링) || | | DNS | Host 이름에 대한 IP 주소 통보기능 || | | NFS | SUN에서 개발한 분산형 파일 시스템 || 전송계층 | End-to-End Data 전송 | TCP | 연결 지향 Protocol || | | UDP | 비연결 지향 Protocol || | | SCTP | 신뢰성 제공 (UDP+TCP), 4Way handshaking 사용 || 인터넷계층 | OSI의 Network 계층 | IP | 목적지까지 패킷 전달 (IPv4, IPv6) || | Routing (경로 설정) | IPx | PC용 Network, 경로 선택, 패킷 처리 || | Gateway (Network 간 Data 연결) | ARP | 논리 주소 IP로 물리 주소 IP(MAC)를 탐색 || | | RARP | 물리 주소 IP로 논리 주소 IP를 탐색 || | | BOOTB | 디스크 없는 시스템 부팅 시 사용 || | | DHCP | 임시 IP 주소 할당 기술 || | | ICMP | IP 계층 이용 Message 교환 (ping) || | | IGMP | 인터넷 그룹 관리, Multicast 그룹을 router에게 통보 || 링크계층 | 기존 표준 기술 지원 | Etehrenet | 기존의 모든 표준 Protocol과 기술적 호환성 유지 || | | X.25 | | 출처 OSI OSI model 정보관리기술사 &amp; 컴퓨터시스템응용기술사 - 성안당","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"network","slug":"Dev/network","permalink":"http://lazyrodi.github.io/categories/Dev/network/"}],"tags":[{"name":"osi7, tcp/ip","slug":"osi7-tcp-ip","permalink":"http://lazyrodi.github.io/tags/osi7-tcp-ip/"}]},{"title":"Jekyll에 Disqus 적용하기","slug":"2016-07-04-etc-disqus","date":"2016-07-04T04:47:50.000Z","updated":"2016-07-11T13:58:03.517Z","comments":true,"path":"2016/07/04/2016-07-04-etc-disqus/","link":"","permalink":"http://lazyrodi.github.io/2016/07/04/2016-07-04-etc-disqus/","excerpt":"","text":"이 문서는 Jekyll 시절에 작성한 것으로 현재 이 사이트에서 유효하지 않음. Disqus는 각종 Framwork을 이용한 웹사이트에 Comment를 달게 해주는 서비스이다. 사용자는 Disqus, Facebook, Twitter, Google 계정을 이용하여 comment를 남길 수 있다. 지원하는 Framework 이랄까 Platform이랄까… Universal Code Wordpress Blogger Tumblr Squarespace TypePad MovableType Drupal Joomla 목표github.io에 [Jekyll][Jekyll]을 이용해서 Static page들로 운영(?)을 하고 있는데, 각 post에 comment를 달아보려 한다. 1. Disqus 가입Disqus 에 가입한다. 가입 과정에 Installation이 있다. Universal Code를 선택한다. 2. Jekyll에 적용이후 /layouts/post.html 의 하단에 Disqus에서 제공하는 소스를 넣으면 끝난다. 너무 빨리 끝나서 놀랐다. (…) 12345678910111213141516171819202122&lt;div id=\"disqus_thread\"&gt;&lt;/div&gt;&lt;script&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () &#123; this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable &#125;; */ (function() &#123; // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//lazyrodi.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); &#125;)();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=\"https://disqus.com/?ref_noscript\" rel=\"nofollow\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; this.page.url과 this.page.identifier는 Disqus thread가 중복되어 생성되는 것을 방지하기 위해 설정하는데 다음과 같이 하면 된다. url에는 본인의 것을 넣으면 된다. 아래 \\는 코드가 반영되어 버려서 어쩔 수 없이 넣었다. 실제 소스에 반영할 땐 제거할 것. 12this.page.url = \"http://lazyrodi.github.io\\&#123;\\&#123; page.url &#125;&#125;\";this.page.identifier = \"\\&#123;\\&#123; page.url &#125;&#125;\"; 3. Comment count 표시하기thread 별로 달린 comment의 개수를 확인하여 post list나 각 post의 상단 등에 표시하기 위해서는 아래의 과정이 필요하다. &lt;/body&gt; 전에 아래 코드 추가 default.html 에서 &lt;/body&gt; 전에 아래 코드를 넣는다. 원래 의도대로면 count를 표시하고 싶은 page에만 넣으면 된다.12&lt;script id=\"dsq-count-scr\" src=\"//lazyrodi.disqus.com/count.js\" async&gt;&lt;/script&gt; count를 표시하기 원하는 page에 아래 코드를 넣는다. 12345&lt;!-- post.html --&gt;&lt;a href=\"\\&#123;\\&#123; page.url &#125;&#125;index.html#disqus_thread\" data-disqus-identifier=\"\\&#123;\\&#123; page.url &#125;&#125;\"&gt;&lt;/a&gt;&lt;!-- index.html --&gt;&lt;a href=\"\\&#123;\\&#123; post.url &#125;&#125;index.html#disqus_thread\" data-disqus-identifier=\"\\&#123;\\&#123; post.url &#125;&#125;\"&gt;&lt;/a&gt; 주절주절local에서만 발생하는 이슈인지는 모르겠지만 Disqus 서버와의 동기화 속도가 조금 느린 것 같다. comment를 달았다가 삭제하면 한참 1 comment 상태로 남아있다. comment를 한 번 달아야 thread가 생성되어 그 전에는 0 comment 표시가 되지 않는 문제(?)가 있다. 페이지를 JavaScript로 억지로 구현해 두었는데 refresh 문제인지 그쪽엔 html code까지는 같은데 반영이 안 된다. ㅠㅠ","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"etc","slug":"Dev/etc","permalink":"http://lazyrodi.github.io/categories/Dev/etc/"}],"tags":[{"name":"jekyll, disqus","slug":"jekyll-disqus","permalink":"http://lazyrodi.github.io/tags/jekyll-disqus/"}]},{"title":"[Java] Queue","slug":"2016-07-03-java-queue","date":"2016-07-03T04:47:50.000Z","updated":"2016-07-11T13:57:17.724Z","comments":true,"path":"2016/07/03/2016-07-03-java-queue/","link":"","permalink":"http://lazyrodi.github.io/2016/07/03/2016-07-03-java-queue/","excerpt":"","text":"Queue의 종류Queue는 공통적으로 Front, Rear 두 개의 pointer를 갖는다. Queue는 Array나 Linked List를 사용하여 구현한다. Simple or linear Queue 일반적으로 Linked-list로 구현된다. FIFO(First In First Out)의 기본을 기킨다. Circular Queue 말 그대로 head와 rear가 이어져있는 구조. Priority Queue 각 개체(node, item, etc.)가 Priority를 가지고 있어서 First in은 성립하지만 Priority가 높은 녀석이 먼저 나오게 된다. Dequeue Double-Ended Queue를 의미하며 front (head) 쪽과 back (tail) 쪽 모두에서 추가/삭제될 수 있는 구조를 말한다.Head-tail linked list 라고도 불리운다. java.util.QueueJava에서는 기본적으로 Queue를 지원한다. (실제로 이걸 사용한 코드는 적어도 회사에서는 본 적 없다.) 이 Queue는 Java Collections Framework에 속한 interface로 세부 내용들은 구현 해주어야 한다. Java Collections Framework에 속한 interface들은 다음과 같은 것들이 있다. java.util.Collection에 속한 것들 java.util.Set java.util.SortedSet java.util.NavigableSet java.util.Queue java.util.concurrent.BlockingQueue java.util.concurrent.TransferQueue java.util.Degue java.util.concurrent.BlockingDegue java.util.Map에 속한 것들 java.util.SortedMap java.util.NavigableMap java.util.concurrent.ConcurrentMap java.util.concurrent.ConcurrentNavigableMap 이걸 바로 사용하기 위해서는 아래와 같은 방식으로 사용 용도에 맞게 초기화 해주어야 한다. 12345Queue&lt;Integer&gt; aQueue = new LinkedList&lt;Integer&gt;();Queue&lt;Integer&gt; bQueue = new PriorityQueue&lt;Integer&gt;();Queue&lt;Integer&gt; cQueue = new LinkedBlockingQueue&lt;Integer&gt;();Queue&lt;Integer&gt; dQueue = new ArrayBlockingQueue(20);Queue&lt;Integer&gt; eQueue = new PriorityBlockingQueue&lt;Integer&gt;(); 해보자기본적인 add (혹은 push)와 poll (혹은 pop)을 Linked List로 구현해보자. Node사용할 Node를 만든다. 123456789101112public class Node&lt;T&gt; &#123; private T item; Node&lt;T&gt; next; Node(T item) &#123; this.item = item; &#125; public T getItem() &#123; return item; &#125;&#125; QueueNode를 이용한 Queue를 생성한다. 1234567891011121314151617181920212223242526272829303132333435363738public class MyQueue&lt;T&gt; &#123; Node&lt;T&gt; head; Node&lt;T&gt; rear; MyQueue() &#123; head = null; rear = null; &#125; public void add(T item) &#123; if (head == null) &#123; head = new Node&lt;T&gt;(item); rear = head; &#125; else &#123; Node&lt;T&gt; newNode = new Node&lt;T&gt;(item); rear.next = newNode; rear = newNode; &#125; &#125; public T poll() &#123; Node&lt;T&gt; tmp = null; T ret = null; ret = (head != null) ? head.getItem() : null; if (head == rear) &#123; head = null; &#125; else &#123; tmp = head; head = head.next; tmp = null; &#125; return ret; &#125;&#125; Use그리고 사용하자. 아래 예시에서는 3개를 넣고 4개를 빼기 때문에 NullPointerException이 발생한다. 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; MyQueue&lt;Integer&gt; mQueue = new MyQueue&lt;Integer&gt;(); mQueue.add(1); mQueue.add(2); mQueue.add(3); try &#123; System.out.println(mQueue.poll()); System.out.println(mQueue.poll()); System.out.println(mQueue.poll()); System.out.println(mQueue.poll()); &#125; catch (NullPointerException e) &#123; System.out.println(\"null\"); &#125; &#125;&#125; 출처아래의 글들을 교재삼아 작성하였습니다. http://krishneshsingh.blogspot.kr/p/what-is-queue-explain-types-of-queue.html javadoc-queue javadoc-collection","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"java","slug":"Dev/java","permalink":"http://lazyrodi.github.io/categories/Dev/java/"}],"tags":[{"name":"algorithm, data structure, queue, java","slug":"algorithm-data-structure-queue-java","permalink":"http://lazyrodi.github.io/tags/algorithm-data-structure-queue-java/"}]},{"title":"Regular Expression (정규표현식)","slug":"2016-07-02-etc-regular-expression","date":"2016-07-02T14:02:50.000Z","updated":"2016-07-18T15:25:35.931Z","comments":true,"path":"2016/07/02/2016-07-02-etc-regular-expression/","link":"","permalink":"http://lazyrodi.github.io/2016/07/02/2016-07-02-etc-regular-expression/","excerpt":"","text":"Regular Expression(정규 표현식)은 줄여서 REGEX(레젝스) 라고 부르기도 한다. 특정한 패턴의 문자열을 검색하고 필요하면 편집하기 위해 사용한다. 정규 표현식은 다음과 같이 분류할 수 있다. POSIX Regular Expression (UNIX 계열 표준 정규 표현식) BRE (Basic Regular Expression) ERE (Extended Regular Expression) BRE에 추가적인 메타 문자 등을 제공 PCRE (Perl Compatible Regular Expression) ?, +, {} 등의 메타 문자는 ERE에서만 사용 가능하다. Meta character (메타 문자) a.k.a Wild card characterIT용어사전에서 정의하고 있는 메타 문자의 사전적인 의미는 다음과 같다. 정규 표현식에서의 메타 문자는 다른 문자의 정보를 운반하기 위해 프로그램 소스나 데이터에 끼워 넣는 문자. 예를 들면 C언어 프로그램에 사용된 백슬레시가 그 예인데, 이 문자 다음에 오는 문장은 확장 문자열(escape sequence)에 속하는 부분으로서 주변 장치와 프로그램에 대해서 어떤 명령을 수행하도록 하는 제어 문자로 사용된다.[네이버 지식백과] 메타 문자설 명비 고 .모든 문자 |왼쪽 또는 오른쪽과 일치cat|dog []문자 집합 중 하나와 일치[a-z]면 a-z 중 하나 [^]문자 집합을 제외하고 일치[^a-z]면 a-z가 아닌 것 중 하나 *문자가 0개 이상 반복될 때 +문자가 1개 이상 반복될 때 {n}문자가 n번 반복될 때a{3} {m, n}문자가 m번 이상 n번 이하 반복될 때 {n,}문자가 n번 이상 반복될 때 \\Escape [\\b]Back space \\fForm Feed \\nLine Feed \\rCarrige Return \\tTab \\vVertical Tab \\d0~9 사이의 숫자 하나[0-9] \\D숫자를 제외한 문자 하나[^0-9] \\w대소문자와 밑줄을 포함하는 모든 영숫자[a-zA-Z0-9] \\W영숫자가 아니거나 밑줄이 아닌 모든 문자[^a-zA-Z0-9] \\s모든 공백 문자[\\f\\n\\r\\t\\v]\\S공백 문자가 아닌 모든 문자[^\\f\\n\\r\\t\\v]\\x16진수 표현\\x0A (=ascii 10 == \\n)\\08진수 표현\\011 (=ascii 9 == \\t)\\c제어문자\\cZ (Ctrl+Z)^, \\A문자열의 시작 ([] 밖에 있을 때) $, \\Z문자열의 끝 \\&lt; 단어의 시작과 일치 \\&gt; 단어의 끝과 일치 \\b 단어 경계와 일치 \\B 단어 경계가 아닐 때 일치 () group 또는 back reference를 정의한다. ?= 전방탐색 ?&lt;= 후방탐색 ?! 부정형 전방탐색 ?&lt;! 부정형 후방탐색 \\l 다음에 오는 글자를 소문자로 변환 \\L \\E를 만날 때까지 모든 문자를 소문자로 변환\\u 다음에 오는 글자를 대문자로 변환 \\U \\E를 만날 때까지 모든 문자를 대문자로 변환\\E \\L 또는 \\U 의 End point 줄 바꿈 Windows: \\r\\n UNIX, LINUX: \\n 읽는 법 !: Exclamation point “: Quotation mark ‘: Apostrophe `: Grave .: Period ^: Caret *: Asterisk -: Hyphen _: Underscore ~: Tilde &amp;: Ampersand (): Parenthesis {}: Brace []: Bracket &lt;&gt;: Chevron Back reference 매칭된 결과를 다시 사용하는 패턴 ()로 묶인 패턴 매칭을 \\# 형태로 재사용할 수 있다. #은 숫자. \\1, \\2, \\3 … ex. (a) = \\1 의 매칭 결과는 a = a 가 된다. HTML Tag를 parsing할 때 굉장히 효율적이다. ex. &lt;(table)&gt;[.]*&lt;\\/\\1&gt; REGEX in JAVAJAVA에서 정규 표현식을 사용하여 Pattern을 찾기 위해서는 아래와 같이 코드를 사용한다. 1234567891011121314151617181920import java.util.regex.Matcher;import java.util.regex.Pattern;public class Main &#123; public static void main(String[] args) &#123; String data = \"dog, cat and wolfwolfwolfwolfwolf\"; Pattern p = Pattern.compile(\"^(dog), (cat) and (wolf)&#123;3&#125;\"); Matcher m = p.matcher(data); if (m.find()) &#123; System.out.println(m.group(0)); // 매칭된 full string System.out.println(m.group(1)); // 매칭된 full string 내의 첫 번째 group System.out.println(m.group(2)); System.out.println(m.group(3)); System.out.println(m.group(4)); // 이 예제에서 4번째 group은 없으므로 exception 발생 &#125; &#125;&#125; 위 코드의 수행 결과는 다음과 같다. 1234567dog, cat and wolfwolfwolfdogcatwolfException in thread \"main\" java.lang.IndexOutOfBoundsException: No group 4 at java.util.regex.Matcher.group(Unknown Source) at com.lazyrodi.Main.main(Main.java:19) 위 코드에서 일치하는 다음 문장을 찾기 위해서는 m.find() 를 한 번 더 수행하면 다음 매칭되는 문장을 찾는다. Pattern Class 및 Matcher Class에 대한 자세한 정보는 JavaDoc (Pattern, Matcher)을 참조하자. Tiphttps://regexper.com 라는 웹사이트에서 정규 표현식을 시각적으로 확인할 수 있게 도와주고 있다. 개인적으로 짱짱맨 사이트라고 생각한다. JavaScript에 대한 정규표현식 사용은 Mozilla 사이트에서 잘 설명하고 있다. 예시 11^(dog), (cat) and (cat)&#123;3&#125; Regexper 결과 1 출처아래의 글들을 교재삼아 작성하였습니다. Regular Expression - Mozilla Pattern Class - JavaDoc Matcher Class - JavaDoc","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"etc","slug":"Dev/etc","permalink":"http://lazyrodi.github.io/categories/Dev/etc/"}],"tags":[{"name":"regex, regular expression","slug":"regex-regular-expression","permalink":"http://lazyrodi.github.io/tags/regex-regular-expression/"}]},{"title":"Memory management","slug":"2016-07-01-common-memory-management","date":"2016-07-01T11:00:00.000Z","updated":"2016-07-18T15:21:00.538Z","comments":true,"path":"2016/07/01/2016-07-01-common-memory-management/","link":"","permalink":"http://lazyrodi.github.io/2016/07/01/2016-07-01-common-memory-management/","excerpt":"","text":"CPU가 접근 가능한 저장소는 CPU 내부의 Register그리고 Main memory이다. CPU는 여기에서 command를 load하여 processing 한다. 보통 CPU는 register에 1 clock cycle 내에 접근이 가능하다. 하지만 만약 command가 Main memory에 있을 경우 1 clock이상의 시간이 소요되어 stall(지연)된다. 이러면 낭비가 심해지기 때문에 CPU와 Main memory 사이에 Cache를 두어 문제를 해결한다. Program은 Binary execution file 형태로 디스크에 저장되어 있으며 실행되기 위해서는 Main memory로 올라와서 Process가 되어야 한다. Process는 효율적인 실행을 위해 디스크와 Main memory 사이를 왔다갔다 하는데 이 때 Main memory에 올라오기 위해 대기하고 있는 Process들의 집합을 Input Queue라 부른다. 코드에서 사용하는 symbol 형태(ex. pointer, *a)는 Compiler에 의해 Relocatable address(재배치 가능 주소)로 binding되고 이는 linkage editor 또는 loader에 의해 Absolute address(절대 주소, 물리 주소)로 binding된다. Binding은 시점에 따라 세 가지로 나눌 수 있다. Compile time binding Compile time에 Memory 내의 위치를 직접 알 수 있으면(process가 R번지부터 시작한다는 사실) Compiler는 Absolute code(절대 코드)를 생성할 수 있다. 하지만 이 위치가 변경되어야 한다면 이 코드는 다시 compile되어야 한다. Load time binding Compile time에 적재 장소를 알 수 없다면 Compiler는 Binary code를 Relocatable code로 만들어야 한다. Relocatable code는 시작 주소가 변경되더라도 사용자 코드를 다시 reload만 하면 된다. Excution binding Process가 실행되는 중간에 memory 내의 한 segment에서 다른 segment로 옮겨질 수 있을 때 “바인딩이 실행 시간까지 허용되었다” 라고 이야기 하며, 이것이 가능하려면 특별한 Hardware를 이용해야 한다. CPU가 생성하는 주소를 Logical address(논리 주소)라 하며, Memory가 다루는 주소를 Physical address(물리 주소)라 한다. Compile time binding, Load time binding에서는 Logical address와 Physical address가 같지만 Excution binding에서는 서로 다르다. 이 때 사용하는 Logical address를 Virtual address라고 부른다. Virtual address 프로그램 실행 중 Physical address로 바뀌어야 하는데 이 바꾸는 작업을 Mapping이라 하며 MMU (Memory Management Unit)에서 작업이 이루어진다. Dynamic Loading(동적 적재) Physical memory 크기의 제한때문에 큰 program의 경우 미리 memory에 모두 올라와있지 못한다. 이를 해결하지 위해 Dynamic Loading이 사용된다. 각 routine은 실제 호출되기 전까지는 memory에 올라오지 않고 relocatable 상태로 disk에 대기하고 있다가 Main program이 memory에 올라와 실행되고 이 routine이 다른 routine을 호출하게 되면 호출된 routine이 이미 memory에 laoding되어 있는지 확인한다. 없으면 Relocatable linking loader가 호출되어 요구된 routine을 memory로 가져오고 이러한 변화를 테이블에 기록해 둔다. 그 후 CPU 제어는 중단되었던 routine으로 보내진다. Swapping Process가 실행되기 위해서는 memory에 있어야 하지만 항상 점유하고 있을 수는 없다. 따라서 실행되는 도중에 임시로 Sub memory로 보내졌다가 다시 Main memory로 돌아올 수 있다. Swapping을 변형하여 우선순위를 두어 처리하는 것을 Roll-in, Roll-out 이라고도 부른다. Swapping system은 Context-switching time이 상당히 오래 걸린다. Fragmentation memory의 이곳 저곳을 점유하다보면 크기에 따라 중간중간 비는 공간이 나타나게 되고 이를 Fragmentation이라 부른다. Fragmentation 문제를 해결하기 위해 두 가지 기법을 사용할 수 있다. Paging Segmentation Paging Physical memory는 frame이라는 같은 크기의 block들로 나누어져 있고 Logical memory는 page라는 같은 크기의 block들로 나누어져 있다. CPU에서 나오는 모든 주소는 Page number(p)와 Offset(d)로 구성된다. Page number는 Page table에 access할 때 사용되며 Page table은 Main memory에서 각 page가 점유하는 주소를 가지고 있다. 이 주소에 Offset을 더하면 원하는 Physical address가 된다. {:class=”img-responsive”} Frame 및 Page의 크기는 Hardware에 의해 정의되며 Page의 크기는 일반적으로 512 byte ~ 16 MB 사이이며 2의 제곱으로 증가한다. Logical address의 크기가 2^m 이고 page가 2^n의 크기를 갖는다면 Logical address의 상위 m-n 비트는 page number를 나타내고, 하위 n 비트는 page offset을 나타낸다. {:class=”img-responsive”} Segmentation 사용자는 하나의 Program을 subroutine, procedure, function 또는 module들을 가지고 있는 것으로 생각하고, Table, Array, Stack 등의 다양한 변수를 사용한다. 이러한 사용자가 바라보는 Memory의 관점을 그대로 지원하는 Memory Management 기법이다. 쉬운 구현을 위해 Segment name 대신 Segment number가 System에 의해 매겨지고 Segment는 number로 불리운다. 때문에 Logical address는 &lt;segment-number, offset&gt;으로 구성된다. {:class=”img-responsive”} Virtual Memory Process 전체가 Memory에 올라오지 않더라도 실행이 가능하게 하는 기법이다. Physical memory로부터 사용자 관점의 Logical memory를 분리시켜 Main memory를 균일한 크기의 저장 공간으로 구성된 엄청나게 큰 배열로 추상화시켜 준다. 장점 (Physical) Memory size의 제약으로부터 자유로워진다. File의 공유를 쉽게 해주고 Shared memory 구현을 가능케 한다. Process 생성을 효율적으로 처리할 수 있는 Mechanism을 제공한다. 많은 program을 동시에 수행 가능하고 이에 따라 응답 시간(response time, turnaround time)은 늘어나지 않으면서도 CPU 이용률(utilization)과 처리율(throughput)이 높아진다. swap하는데 필요한 입/출력 횟수가 줄어들어 program들이 상대적으로 빠르게 실행된다. 단점 구현하기 어렵다. 잘못 사용하면 성능이 크게 저하된다. 앞에서 본 Memory management 기법 중 Dynamic loading은 process 전체를 memory에 올려야 한다는 제약을 어느정도 막아주긴 하지만 프로그래머가 추가적인 작업을 해야한다. 앞서 본 것처럼 page frame들로 인해 Physical memory는 연속적인 공간이 아닐 수 있다. MMU(Memory Management Unit)는 Physical memory를 Logical memory로 mapping한다. Virtual Memory의 각 area는 다음과 같이 사용된다. Stack main() 함수, Callback 함수의 주소, 지역변수, 파라미터, return value가 저장되는 영역이다. Sparse 빈 공간을 포함한 Stack과 Heap 사이의 영역이다. Heap 동적 메모리 할당 영역이다. Data 전역변수, 정적변수(static), 배열, 구조체, 상수가 저장되는 영역이다. Data 영역은 두 가지 영역으로 구분할 수 있다. Data 초기값이 있는 경우 BSS (Block Started by Symbol) 초기값이 없는 경우우 Code 작성한 Code가 저장되는 영역이다. {:class=”img-responsive”} Code, Data, Stack 영역은 Compiler가 Memory의 크기를 결정한다. Heap 영역의 크기는 개발자에 의해 프로그램 동작 시 결정된다. Stack의 지역변수는 사용 후 소멸하므로 데이터 용량이 불확실하다. 따라서 밑에서부터 올라가면서 값이 채워진다. Heap overflow Heap 영역이 Stack 영역을 침범한 경우 Stack overflow Stack 영역이 Heap 영역을 침범한 경우 아래 그림은 wikipedia에서 설명하고 있는 동적 할당에 대한 그림이다. {:class=”img-responsive”} 출처아래의 글들을 교재삼아 작성하였습니다. http://blog.naver.com/k5248/220724196178 https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EB%A9%94%EB%AA%A8%EB%A6%AC_%ED%95%A0%EB%8B%B9 Operating System Concepts (공룡책)","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"common","slug":"Dev/common","permalink":"http://lazyrodi.github.io/categories/Dev/common/"}],"tags":[{"name":"computer memory","slug":"computer-memory","permalink":"http://lazyrodi.github.io/tags/computer-memory/"}]},{"title":"Fundamental of Database","slug":"2016-04-13-db-fundamental-of-database","date":"2016-06-30T11:00:00.000Z","updated":"2016-07-18T15:20:29.727Z","comments":true,"path":"2016/06/30/2016-04-13-db-fundamental-of-database/","link":"","permalink":"http://lazyrodi.github.io/2016/06/30/2016-04-13-db-fundamental-of-database/","excerpt":"","text":"Database는 간단히 데이터들의 모임 이라고 보면 된다. 아래의 속성들을 충족해야 한다. 의존성 일관성 보안성 경제성 무결성 결론뜬금없이 두괄식 정리를 해본다. Database장점단점HDB구조가 간단하고 판독이 용이하다.데이터 상호 간의 유연성이 부족하다.구현, 수정, 검색이 용이하다.검색 경로가 한정되어 있다.데이터 액세스 속도가 빠르다.삽입/삭제 연산이 매우 복잡하다.데이터의 사용량을 쉽게 예측 가능하다.다 대 다 관계를 처리하기 어렵다.NDB상하 종속적인 관계를 쉽게 해결한다.구성, 설계가 복잡하다.데이터의 종속성을 해결하지 못한 시스템이다.RDB데이터의 일관성을 보증할 수 있음. (Transaction)대량 데이터 처리 시 성능 이슈.정규화를 전제로 하기 때문에 갱신 시의 비용이 적게 든다.갱신이 발생한 Table의 인덱스 생성이나 스키마 변경에 대한 처리 이슈.JOIN 등 복잡한 검색 조건으로 검색이 가능함.Column을 확실히 정의하기 어려운 경우에 대한 처리 이슈.간결하고, 보기 편하다.단순히 빨리 결과를 조회하고자 할 때의 성능 이슈.OODBNoSQL대량의 Record 처리에 유리하다.JOIN 연산이 불가능하다. Database의 구성요소 Database Schema DBMS (Database Management System) Database Language Database Storage User Database의 종류 File System - File type HDB (Hierachical Database, 계층형 데이터베이스) - Segment type NDB (Network Database, 네트워크형 데이터베이스) - Record type RDB (Relational Database, 관계형 데이터베이스) - Table type OODB (Object-Oriented Database 객체지향형 데이터베이스) - Class type NoSQL (Not only SQL) Database의 종류File System말 그대로 파일시스템을 의미한다. HDB (Hierachical Database) 트리구조를 기반으로 하는 계층형 데이터 모델을 사용한다. 데이터는 트리 형태로 구성되며 각 데이터 요소(Entity)들은 상하 관계를 나타내는 Link로 구성된다. 제품 Adabas GT.M IMS MUMPS Cache Metakit Multidimensional hierachical toolkit Mumps compiler DMSII FOCUS NDB (Network Database) 그래프 구조를 기반으로 하는 네트워크형 데이터 모델을 사용한다. 이는 Entity와 Entity 간의 Relationship을 그래프로 연결한다. HDB와 비슷하지만 부모(상위 Entity)를 여러 개 가질 수 있다. 제품 IDS IDMS RDM Embedded RDM Server 터보이미지 유니박 DMS-1100 RDB (Relational Database) 현재까지 가장 안정적이고 효율적인 Database로 알려져있다. Entity를 Table로 사용하고 Entity 간의 공동 Attribute를 이용하여 서로 연결하는 독립된 형태의 데이터 모델이다. SQL을 사용한다. 제품 Oracle (Oracle) MS-SQL Serve (Microsoft) MySQL (Oracle -SunMicroSystems-) DB2 (IBM) Infomix (IBM) Sybase (Sybase) Derby (Apache) SQLite (Opensource) OODB (Object-Oriented Database) Class, Object, Attribute, Method, Instance, Capsulation, Inheritance 등을 기반으로 데이터를 구조화하는 데이터 모델이다. 비지니스형 데이터 타입만 처리되는 RDBMS의 기본적인 제한점을 극복하기 위해 고안되었다. NoSQL (Not only SQL) SQL을 사용하지 않는다는 뜻이다. Schema가 없다. 대용량 데이터 처리에 유리하고 분산 처리가 가능하여 Cloud computing에 유리하다. 종류 Key/Value type Memchached Tokyo Tyrant Flare Roma Redis Document type: 여러가지 형태의 값들을 모아둔 논리적 구조. MongoDB CouchDB Big Table (Column) type: RDB는 Row 단위로 데이터를 관리하지만 Colume type은 Column 단위로 데이터를 관리한다. HBase Casandra Hypertable Schema (Meta-Data)Database의 구조 및 제약 조건에 대해 전반적으로 기술한 것을 Schema라고 한다. Entity(Table), Attribute(Field), Relationship 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 대해 정의한다. Schema는 Data Dictionary에 저장된다. 쉽게 말해 Data structure가 어떻게 생겼는지 정의하며, RDB에서는 아래 코드처럼 생겼다. 12345678910Player ( name CHAR(20), number INTEGER(4));Status ( number INTEGER(4), point INTEGER(4), trophy CHAR(20)); DBMS기존 파일 시스템이 갖는 데이터 종속성과 중복성 문제를 해결하기 위해 제안된 시스템으로 모든 Application들이 Database를 공용으로 사용할 수 있도록 관리한다. DBMS의 궁극적 목표는 데이터의 독립성이다. 논리적 독립성: Application과 Database를 독립시켜 Data에 변경이 발생하여도 Application은 변경되지 않는다. 물리적 독립성: Application과 Storage를 독립시켜 디스크에 변경이 발생하여도 Application은 변경되지 않는다. DBMS의 필수 기능 정의 (Definition): Type 및 Structure에 대한 정의, 이용 방식, 제약 조건을 정의한다. 조작 (Manipulation): 데이터의 검색, 갱신, 삽입, 삭제 등의 처리를 위해 User와 Database 사이의 Interface를 제공하는 것을 의미한다. 제어 (Control): 데이터의 정확성, 무결성, 보안 및 권한 검사, 병행수행 제어 등의 기능을 정한다. Releationship (관계) 일 대 일 일 대 다 다 대 다 Key조건을 만족하는 Tuple을 찾거나 순서대로 정렬할 때 Tuple들을 구분할 수 있는 기준이 되는 Attribute를 의미한다. Candidate Key (후보키)Relation을 구성하는 Attribute들 중에서 Tuple을 식별하기 위해 사용하는 Attribute들의 부분 집합을 의미한다. Primary Key로 사용할 수 있는 Attribute이다. ex) 주민 Relation에서의 주민등록번호 또는 지문 유일성 (Unique): 하나의 Key 값으로 하나의 Tuple만을 식별할 수 있어야 한다. 최소성 (Minimality): 모든 Record들을 유일하게 식별하는데 꼭 필요한 Attribute들로만 이루어져야 한다. Primary Key (기본키)Candidate Key 중 선택한 Main Key를 의미하며 NULL 이 될 수 없다. Alternate Key (대체키)Candidate Key가 두 개 이상일 때 Primary Key를 제외한 나머지 Candidate Key들을 의미하며 보조키라고도 부른다. Super Key (슈퍼키)하나의 Table 내에 있는 Attribute들의 집합으로 구성된 Key를 말한다. Table을 구성하는 모든 Tuple 중 Super Key로 구성된 Attribute의 집합과 동일한 값은 나타나지 않는다. Super Key는 Table을 구성하는 모든 Tuple에 대해 유일성은 만족시키지만 최소성은 만족시키지 못한다. Foreign Key (외래키)두 개의 Table이 Relationship을 맺고있을 때 A의 Primary Key와 같은 B의 Attribute 를 Foreign Key 라 부른다. 즉, 아래 그림에서 A가 B를 참조한다고 하면 B의 주민등록번호는 Primary Key가 되고 A의 주민등록번호는 Foreign Key가 된다. Field가 적어서 예시가 적절하지 않은 것도 같고… {:class=”img-responsive”} Foreign Key를 사용하면 실수로 Data를 삭제하는 것을 막을 수 있다. 다른 Table의 Foreign Key로 참조하고 있는 Row는 Table에서 삭제할 수 없기 때문이다. 이를 참조 무결성(Reference Integrity)이라고 부른다. Integrity (무결성) 이란 데이터를 보호하고 항상 정상인 상태를 유지하는 것을 말한다. 개체 무결성 Table에서 Primary Key를 구성하는 Attribute는 NULL이나 중복값을 가져서는 안 된다. 참조 무결성 Foreign Key의 값은 NULL이나 참조 Table의 Primary Key값과 동일해야 한다. 즉, Table은 참조할 수 없는 Foreign Key의 값을 가질 수 없다. (실수로 삭제하는 것을 예방할 수 있는 이유이다.) Foreign Key와 참조하려는 Table의 Primary Key는 Domain과 Attribute의 개수가 같아야 한다. Transaction한 단위를 이루는 일련의 연관된 데이터베이스 조작. 하나의 Transaction에 속하는 작업 중 하나라도 실패하면 Transaction 전체가 실패한 것으로 간주하여 변경한 내용을 모두 원래대로 되돌려 놓는다. 이를 Rollback이라 한다. 모든 작업이 성공적으로 처리되면 모든 변경 내용을 한꺼번에 반영하고 이를 Commit이라 한다. Transaction의 특성 (ACID) Atomicity (원자성) Transaction에 포함된 모든 작업이 성공적으로 처리되지 않으면 어떠한 작업도 처리되지 않아야 한다. Consistency (일관성) Transaction의 시작 전과 종료 후의 Database가 일관된 상태를 유지해야 한다. 참조 무결성이 깨져서는 안된다. Isolation (고립성) 하나의 Transaction에서 Database를 변경한 내용은 Transaction이 Commit될 때까지 다른 어떤 Query나 Transaction과도 고립되어야 한다. Durability (영속성) Commit이 이루어지면 Transaction에 의해 변경된 내용은 영구적으로 유지되어야 한다. DBMS는 Database의 현재 상태가 유실되지 않도록 시스템 충돌 등의 문제로부터 복구할 수 있는 방안을 갖춰야 한다. 용어 Table Relation(관계) 또는 Entity(개체)라 부른다. Column(열, ↕) 과 Row(행, ↔) 으로 구성된다. Field Attribute(속성)이라고도 한다. Table의 Column을 의미한다. Degree(차수) Attribute의 수를 뜻한다. Record Tuple 이라고도 하며 Table의 Row를 의미한다. Cardinality 하나의 Relation을 구성하는 Tuple(Record)의 수를 의미한다. Domain 하나의 Attribute가 가질 수 있는 같은 type의 Atomic(원자) 집합 을 의미한다. 예) 학생 relation에서 학년의 domain은 1 ~ 6 이다. DBMS (Database Management System) DDL (Data Definition Language) 테이블을 생성하고 삭제하는 언어를 뜻한다. CREATE, ALTER, DROP DML (Data Manipulation Language) = 서브 언어 User가 데이터를 처리할 수 있게 도와주는 도구. SELECT, INSERT, UPDATE, DELETE DCL (Data Control Language) 데이터의 보호, 관리를 위해 사용된다. COMMIT, ROLLBACK, GRANT, REVOKE Scale up 사용 중인 서버를 고성능으로 바꿔 처리 능력을 향상시키는 방법으로 비용이 발생하지만 소스에 대한 변경이 없다. Scale down 저가의 여러 장비를 사용하여 능력을 향상시키는 방법으로 소스에 대한 수정이 필요하다. 주로 NoSQL에서 제공하는 방식이다. 출처아래의 글들을 교재삼아 작성하였습니다. http://dreamzelkova.tistory.com/393 http://blog.naver.com/bobojisu/220561467061 http://ourcstory.tistory.com/30 http://cafe.naver.com/junes81/5895 https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EB%AA%A8%EB%8D%B8","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"database","slug":"Dev/database","permalink":"http://lazyrodi.github.io/categories/Dev/database/"}],"tags":[{"name":"database","slug":"database","permalink":"http://lazyrodi.github.io/tags/database/"}]},{"title":"File IO(Input/Output)","slug":"2016-06-29-java-fileio","date":"2016-06-29T12:02:50.000Z","updated":"2016-07-11T13:57:12.275Z","comments":true,"path":"2016/06/29/2016-06-29-java-fileio/","link":"","permalink":"http://lazyrodi.github.io/2016/06/29/2016-06-29-java-fileio/","excerpt":"","text":"JAVA에서의 파일 입출력은 Stream(데이터의 흐름)을 통해 이루어진다. Stream은 다음과 같이 나눌 수 있다. 흐름의 방향 Input Output Data Type Byte Character Byte streamByte stream의 경우 아래와 같은 Class들을 사용할 수 있다.[ Tutorials Point 에서 퍼온 그림 ] 아래 소스는 input.txt를 8-bit Byte 단위로 data를 읽어서 output.txt 에 복사한다. 12345678910111213141516171819202122232425262728293031import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileIO &#123; public static void main(String[] args) throws IOException &#123; FileInputStream in = null; FileOutputStream out = null; try &#123; in = new FileInputStream(\"input.txt\"); out = new FileOutputStream(\"output.txt\"); int c; while ((c = in.read()) != -1) &#123; out.write(c); &#125; &#125; finally &#123; if (in != null) &#123; in.close(); &#125; if (out != null) &#123; out.close(); &#125; &#125; &#125;&#125; Character streamCharacter stream은 16-bit unicode 단위로 data를 처리한다. Byte stream과 다른 점은 FileReader와 FileWriter를 사용한다는 것이다. 이 두 가지 Class는 내부적으로는 FileInputStream과 FileOutputStream을 사용하지만 한 번에 2 byte 씩 처리한다는 것이 차이점이다. 아래 소스는 input.txt를 16-bit, 2 Byte 단위로 data를 읽어서 output.txt 에 복사한다. 123456789101112131415161718192021222324252627282930import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileIO &#123; public static void main(String[] args) throws IOException &#123; FileReader in = null; FileWriter out = null; try &#123; in = new FileReader(\"input.txt\"); out = new FileWriter(\"output.txt\"); int c; while ((c = in.read()) != -1) &#123; out.write(c); &#125; &#125; finally &#123; if (in != null) &#123; in.close(); &#125; if (out != null) &#123; out.close(); &#125; &#125; &#125;&#125; Scanner위에서 본 것과 같이 입력 파일 처리 시 Byte 또는 Character 단위로 read 하기 때문에 (물론 BufferedReader는 Line 단위로 읽을 수 있지만) Parsing이 상당히 귀찮아진다. Java 5부터 추가된 Scanner를 사용하면 귀찮은 작업을 건너뛸 수 있다. 변수 및 메소드에 대한 정의는 여기를 참조하자. 다양한 type을 지원하며, 정규표현식 (REGEX-Regular Expression-)도 지원한다. 주의할 점은 Scanner 또한 File을 다루기 때문에 close()를 해줘야 한다는 것과 character type과 관련된 메소드는 제공하지 않는다는 것이다. 아래 코드는 input.txt에서 내용을 읽어서 parsing 후 콘솔로 출력한다. 12345678910111213141516import java.io.File;import java.io.IOException;import java.util.Scanner;public class FileIO &#123; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(new File(\"input.txt\")); // File 대신 System.in 을 받을 수도 있다. while (sc.hasNext()) &#123; System.out.println(sc.next()); &#125; sc.close(); &#125;&#125; 추가정보 flush() - Buffer의 내용을 출력(흘려보내고)하고 비운다. close() - 메모리가 낭비되지 않도록 close()를 호출해줘야 하고, close()가 호출 될 때 자동으로 flush()가 수행된다. File Class - File Class가 가지는 메소드들에 대해서는 여기를 참조하자. BufferedInputStream - JavaDoc - BufferedInputStream BufferedOutputStream - JavaDoc- BufferedOutputStream BufferedReader - JavaDoc - BufferedReader BufferedWriter - JavaDoc - BufferedWriter BufferedReader에는 BufferedInputStream에는 없는 readLine() 메소드가 존재하고 BufferedWriter에는 BufferedOutputStream에는 없는 newLine() 메소드가 존재한다. 출처아래의 글들을 교재삼아 작성하였습니다. Tutorials Point - Java java-api","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"java","slug":"Dev/java","permalink":"http://lazyrodi.github.io/categories/Dev/java/"}],"tags":[{"name":"java, fileio","slug":"java-fileio","permalink":"http://lazyrodi.github.io/tags/java-fileio/"}]},{"title":"Opensource License","slug":"2016-06-28-etc-opensource-license","date":"2016-06-28T09:42:50.000Z","updated":"2016-07-18T15:14:03.050Z","comments":true,"path":"2016/06/28/2016-06-28-etc-opensource-license/","link":"","permalink":"http://lazyrodi.github.io/2016/06/28/2016-06-28-etc-opensource-license/","excerpt":"","text":"Software 지적재산권 저작권 특허권 상표권 영업비밀 저작권 (Copyright) 창작물에 대해 창작자(저작자)가 취득하는 권리로 창작과 동시에 권리가 발생한다. 소프트웨어도 작성 시 저작권이 발생하며 저각권은 개인 또는 소속 회사에 부여된다. 저작권자의 허락 없이는 해당 저작물을 복제, 배포 수정할 수 없다. 특허권 (Patent) 발명에 관하여 발명자(특허권자)가 갖는 독점배타권을 말한다. 출원을 통해 등록되어야만 권리가 발생한다. 언어와 관계 없이 방식이 동일하면 소프트웨어 특허에 걸린다. 상표권 (Trademark) 지정상품에 대해 등록상표를 사용할 독점적인 권리를 말한다. 특허와 마찬가지로 등록해야 한다. 상표를 사용하기 위해서는 반드시 상표권자의 허락을 받아야 한다. 영업비밀 비공개 소프트웨어어같은 경우가 해당한다. 영업비밀의 경우 공개되면 법적으로 보호받기 어렵다. 저작권특허권권리발생창작과 동시에 발생특허출원, 심사, 등록권리내용인격권 (공표권, 성명표시권, 동일서유지권)독점배타권 실시권효력범위표현(코드)의 실질적 유사성아이디어 (알고리즘, 기능)의 동일성 Software License 오픈소스에도 지적재산권이 있다. 일반적으로 느슨한 License를 적용하여 수정, 복제, 배포에 별 제약을 두지 않지만 몇 가지 지켜야 할 사항이 있다. 개발자, 기여자, 저작권 정보 표시 코드를 수정한 경우 수정한 정보 표시 수정자, 수정일 등을 기입하여 원본과 구별한다. License 정보 제공 일반인이 해당 License를 잘 이해할 수 있도록 License 정보를 표시 Copyleft (동일한 License로 재 배포)할 것 GPL 등이 대표적이며, 수정한 소스를 배포할 때에도 이전과 동일한 License를 사용해야 한다. Copyleft License들은 소프트웨어 배포 시 소스코드까지 함께 배포할 것을 요구한다. BSD (Berkeley Software Distribution) 배포되는 프로젝트들이 미국 정부의 재원을 사용했기 때문에 소스코드를 공개하지 않아도 된다. 다만 배포 시 저작권 표시, 보증 책임이 없음을 표시해야 한다. 이것만 지킨다면 상용 소프트웨어에도 무제한 사용이 가능하다. 아래 내용이 포함되어야 한다. 1234567891011121314151617181920212223242526The BSD LicenseThe following is a BSD license template. To generate your own license, change the values of OWNER, ORGANIZATION and YEAR from their original values as given here, and substitute your own. Also, you may optionally omit clause 3 and still be OSD conformant.Note: On January 9th, 2008 the OSI Board approved the \"Simplified BSD License\" variant used by FreeBSD and others, which omits the final \"no-endorsement\" clause and is thus roughly equivalent to the MIT License.Historical Note: The original license used on BSD Unix had four clauses. The advertising clause (the third of four clauses) required you to acknowledge use of U.C. Berkeley code in your advertising of any product using that code. It was officially rescinded by the Director of the Office of Technology Licensing of the University of California on July 22nd, 1999. He states that clause 3 is \"hereby deleted in its entirety.\" The four clause license has not been approved by OSI. The license below does not contain the advertising clause.This prelude is not part of the license.= Regents of the University of California= University of California, Berkeley= 1998In the original BSD license, both occurrences of the phrase \"COPYRIGHT HOLDERS AND CONTRIBUTORS\" in the disclaimer read \"REGENTS AND CONTRIBUTORS\".Here is the license template:Copyright (c) , All rights reserved.Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:· Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.· Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.· Neither the name of the nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.` Apache License 아파치 재단 (ASF: Apache Software Foundation)의 모든 소프트웨어에 적용되는 License로 소스 공개 의무가 없다. 단, &quot;Apache&quot; 라는 이름에 대한 상표권을 침해하면 안되고 특허권에 대한 내용이 포함되어 있다. Apache 2.0에 특허 관련 조항이 들어가서 GPL 2.0과의 결합이 어려웠는데 GPL 3.0에서는 이 문제가 해결되어 Apache 코드와 GPL 3.0 코드의 결합이 가능해졌다. 아래 내용이 포함되어야 한다. 12345678910111213Copyright [yyyy] [name of copyright owner]Licensed under the Apache License, Version 2.0 (the \"License\");you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License. GPL 2.0 (General Public Lecense) GPL 2.0이 적용된 코드를 사용할 경우 &quot;본 제품(SW)은 GPL 라이센스 하에 배포되는 SW인 ㅇㅇㅇ를 포함합니다.&quot; 등의 문구를 매뉴얼 혹은 그에 준하는 매체에 포함시키고 GPL 전문을 첨부해야 한다. 코드를 수정하거나 새로운 소프트웨어를 Link(Static, Dynamic 모두) 하는 경우 소스코드 제공 의무 가짐 Object code, Excutable form으로 배포하는 경우 소스코드 자체를 함께 배포하거나 제공받을 수 있는 방법을 기술 자신의 특허를 구현한 코드인 경우 특허 사용료를 받을 수 없음 타인의 특허를 구현한 코드인 경우 특허권자가 사용자에게 사용료를 받지 않겠다고 한 경우에만 배포 가능 예외케이스 GNU Classpath Project와 Java Platform의 경우 소스코드를 공개하지 않고 배포 가능 GPL 2.0은 아래 문구들이 포함되어야 한다. 12One line to give the program's name and a brief idea of what it does.Copyright (C) &lt;year&gt; &lt;name of author&gt; 추가로 아래 문구들이 더 필요하다. 파일 하나짜리 프로그램일 경우 123456789101112This program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;. 파일이 프로그램의 일부일 때 1234567891011121314This file is part of XXXXX.Foobar is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.Foobar is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with Foobar. If not, see &lt;http://www.gnu.org/licenses/&gt;. GPL 3.0 GPL 2.0에 비해 변경점은 다음과 같다. GPL 3.0 소스코드를 특정 제품에 포함시키거나 함께 배포하는 경우, 해당 소스에 설치 정보를 함께 제공해야 한다. 다만, ROM에 설치되는 경우(그 누구도 수정코드를 제품에 설치할 수 없는 경우)에는 설치 정보를 제공하지 않아도 된다. DRM (Digital Rights Management)과 관련된 각국 법률에 의해 보호되는 이익을 포기해야 한다. 특허와 관련하여 원 소스코드를 개선하여 배포한 기여자의 경우 자신이 기여한 부분에 대해서는 비차별적이고 특허 사용료가 없다는 내용의 License를 제공해야 한다. 특허와 관련하여 Licensee 등으로부터 특허 소송이 제기되는 경우 소송을 제기한 날에 특허소송을 제기한 Licensee의 Opensource software license는 종료된다. Apache 2.0 및 Affero GPL과 양립이 가능하다. LGPL 2.1 (Lesser General Public License) 일부 Library에 대하여 GPL보다 소스코드의 공개 정도를 완화된 형태로 사용할 수 있도록 만든 License이다. 상용 소프트웨어 개발자들이 코드 공개때문에 오픈 소스를 사용하지 않을까봐 조금 완화하였다. 소프트웨어 배포 시 저작권 표시, 보증책임 없음 표시, LGPL에 의해 배포된다는 사실을 명시 LGPL Library의 일부를 수정하는 경우 수정한 코드 공개 LGPL Library에 Link(Static, Dynamic)할 경우 해당 소스 공개 불필요. 단, 사용자가 Library 수정 후 동일한 실행 파일을 생성할 수 있도록 Static Linking시에는 Object code를 제공해야 함. GPL과 동일한 저작권 표시를 해야한다. 단, GPL에서의 &#39;프로그램&#39; 을 &#39;라이브러리&#39;로 한다. 라이브러리를 수정한 것이므로... MIT (Massachusetts Institute of Technology) 미국 MIT에서 학생들을 돕기 위해 개발한 License로 MIT를 개조한 제품은 반드시 오픈 소스로 배포해야 한다는 규정이 없다. 아래와 같은 저작권 문구를 포함해야 한다. 12Copyright (c) &lt;year&gt; &lt;copyright holders&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: 이 외에도 MPL(Mozilla Public License), CDDL(Common Development and Distribution License), CPL(Common Public License), EPL(Eclipse Public License) 등 무진장 많아서 더는 못쓰겠다. 그때그때 찾아보자. 아래 표는 한국저작권협회에서 제공하는 자료이다. {:class=”img-responsive”} 정리 BSD (Berkeley Software Distribution) 저작권 표시 필요함 코드 공개 의무 없음 저자 및 기여자들의 이름을 홍보용으로 사용할 수 없음 상용으로 사용 가능 Apache 저작권 표시 필요함 코드 공개 의무 없음 상용으로 사용 가능 GPL (General Public License) 저작권 표시 필요함 GPL 전문 포함해야 함 소스 코드 공개 필요함 LGPL (Lesser General Public License) 저작권 표시 필요함 LGPL Library를 수정한 경우 코드 공개해야 함 LGPL Library를 사용만 한 경우 코드 공개 의무 없음 MIT 소스 공개 의무 없음 Licensing은 Licensor가 Licensee에게 대가를 받고 그 재산권을 사용할 수 있도록 상업적 권리를 부여하는 것이다. 결론 : 상용에서는 GPL을 피하고 MIT, BSD, Apache를 사용하자. 출처아래의 글들을 교재삼아 작성하였습니다. 오픈소스 소프트웨어 라이선스 가이드 2.0 - 문화체육관광부, 한국저작권위원회 Principles of Software Contracts - The LINUX Foundation 한국저작권협회 APACHE Software Foundation GPL 2.0 GPL 3.0","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"etc","slug":"Dev/etc","permalink":"http://lazyrodi.github.io/categories/Dev/etc/"}],"tags":[{"name":"opensource, license","slug":"opensource-license","permalink":"http://lazyrodi.github.io/tags/opensource-license/"}]},{"title":"String-StringBuffer-StringBuilder","slug":"2016-06-27-java-string-stringbuffer-stringbuilder","date":"2016-06-27T11:42:50.000Z","updated":"2016-07-18T15:11:08.071Z","comments":true,"path":"2016/06/27/2016-06-27-java-string-stringbuffer-stringbuilder/","link":"","permalink":"http://lazyrodi.github.io/2016/06/27/2016-06-27-java-string-stringbuffer-stringbuilder/","excerpt":"","text":"살펴보고 돌아서서 5분 후면 까먹는 String, StringBuffer, StringBuilder에 대한 정리. StringString은 Immutable Class (불변 클래스)이다. 불변 클래스라 함은 아래 코드와 같이 str1에 str2를 더했을 때 원래의 객체가 변하는 것이 아니라 새로운 객체가 생성되는 것을 의미한다. 코드 1.12345678String str1 = \"Lazy\";String str2 = \"Rodi\"; System.out.println(\" str1 =&gt; \" + str1 + \": \" + str1.hashCode());System.out.println(\" str2 =&gt; \" + str2 + \": \" + str2.hashCode());str1 += str2;System.out.println(\"str1 += str2; =&gt; \" + str1 + \": \" + str1.hashCode()); 결과값 1. 주소가 바뀐 것을 확인할 수 있다.123 str1 =&gt; Lazy: 2361236 str2 =&gt; Rodriguez: 2552738str1 += str2; =&gt; LazyRodriguez: -1189801674 위의 예제에서 처음 str1이 차지하고 있던 공간이 낭비된다는 것을 알 수 있다. 이 낭비를 막기 위해 StringBuffer를 살펴보자. StringBufferStringBuffer는 Immutable Class가 아니며, append() 메소드를 제공하여 문자열 연산을 할 수 있게 도와준다. 코드 2.123456789StringBuffer strBuf = new StringBuffer();String str1 = \"Lazy\";String str2 = \"Rodriguez\";System.out.println(\"strBuf =&gt; \" + strBuf + \" : \" + strBuf.hashCode());strBuf.append(str1);System.out.println(\"strBuf =&gt; \" + strBuf + \": \" + strBuf.hashCode());strBuf.append(str2);System.out.println(\"strBuf =&gt; \" + strBuf + \": \" + strBuf.hashCode()); 결과값 2. 새로 생성되는 객체가 없다.123strBuf =&gt; : 366712642strBuf =&gt; Lazy: 366712642strBuf =&gt; LazyRodriguez: 366712642 별 차이 없는 것으로 볼 수도 있고, StringBuffer를 생성할 때의 자원이 걱정될 수도 있겠지만, 문자의 + 연산이 빈번하게 이루어진다면 메모리의 낭비가 커질 수 밖에 없고 이 때 StringBuffer를 String보다 효율적으로 사용할 수 있게 된다. String과 StringBuffer 모두 char[] 이다. String은 + 연산 시 새로운 배열을 만들어내고 StringBuffer은 미리 배열을 여유있게 잡아둔다. 이런 이유때문에 StringBuffer의 배열이 꽉 차서 메모리를 더 잡아주는 지점에서 성능 저하가 살짝 나타난다. 보통 StringBuffer가 String 보다 성능이 뛰어나다. String의 경우에도 Compiler가 + 연산을 StringBuffer로 자동 변환해주긴 하지만 모든 + 연산을 커버하지는 않는다고 한다. StringBuilder위에서 살펴본 StringBuffer는 멀티 스레딩 환경에서 Thread-safe를 위해 동기화(Synchronized)가 이루어진다. StringBuilder는 StringBuffer에서 동기화 기능을 제거한 것이다. 고로, 멀티 스레딩 환경이 아니라면 StrigBuilder를 쓰는 것이 낫다. 성능시험간단한 코드로 속도를 비교해 보도록 하자. loop 단위가 작을 때에는 currentTimeMillis() 대신 nanoTime()을 사용하면 된다. (사실 아래 코드가 측정에 적당한 코드인지 불안하긴 하다…)123456789101112131415161718192021222324252627282930313233343536String str1 = \"Lazy\";String str2 = \"Rodriguez\";StringBuffer strBuffer = new StringBuffer();StringBuilder strBuilder = new StringBuilder();int i = 0;long max = 50000;long s, e;s = System.currentTimeMillis();System.out.println(\"'StringBuffer' start = \" + s);for (i = 0; i &lt; max; i++) &#123; strBuffer.append(str2);&#125;e = System.currentTimeMillis();System.out.println(\"'StringBuffer' start = \" + e);System.out.println(\"'StringBuffer' spend time = \" + (e - s));s = System.currentTimeMillis();System.out.println(\"'StringBuilder' start = \" + s);for (i = 0; i &lt; max; i++) &#123; strBuilder.append(str2);&#125;e = System.currentTimeMillis();System.out.println(\"'StringBuilder' start = \" + e);System.out.println(\"'StringBuilder' spend time = \" + (e - s));s = System.currentTimeMillis();System.out.println(\"'+' start = \" + s);for (i = 0; i &lt; max; i++) &#123; str1 += str2;&#125;e = System.currentTimeMillis();System.out.println(\"'+' start = \" + e);System.out.println(\"'+' spend time = \" + (e - s)); 아래 결과는 3회 측정 후 평균 낸 값이다. 기초적인 환경에서는 StringBuilder 성능이 제일 좋다는 것을 알 수 있다. 종류 \\ 수행100회 (ns)1000회 (ns)10000회 (ms)20000회 (ms)30000회 (ms)50000회 (ms)String274526907782953919104208.66710992.67StringBuffer305514.7583808.323.66666766.333333StringBuilder117393.7202339.72.3333332.3333333.3333337 내 맘대로 정리 String 단순한 코드, 문자열의 불변성이 유지되는 코드에서 사용 StringBuffer Thread-safe 환경에서 사용 StringBuilder Single thread 환경에서 문자열 결합에서는 가장 좋은 성능을 보임 출처아래의 글들을 교재삼아 작성하였습니다. http://cafe.naver.com/javachobostudy/2423 http://cafe.naver.com/javachobostudy/36860 http://cafe.naver.com/hitommy/543 java-api String StringBuilder StringBuffer","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"java","slug":"Dev/java","permalink":"http://lazyrodi.github.io/categories/Dev/java/"}],"tags":[{"name":"java, string, stringbuffer, stringbuilder","slug":"java-string-stringbuffer-stringbuilder","permalink":"http://lazyrodi.github.io/tags/java-string-stringbuffer-stringbuilder/"}]},{"title":"작심일일 프로젝트","slug":"2016-06-27-life-jaksimilill","date":"2016-06-27T10:47:50.000Z","updated":"2016-07-10T14:59:00.000Z","comments":true,"path":"2016/06/27/2016-06-27-life-jaksimilill/","link":"","permalink":"http://lazyrodi.github.io/2016/06/27/2016-06-27-life-jaksimilill/","excerpt":"","text":"作心一日뭐든 꾸준히 못 하는 성격인데 인생의 위기가 왔으니 꾸준히 공부를 해보려 한다. 목표는 하루에 글타래 하나 정리하기. (2016-06-27) String-StringBuffer-StringBuilder (2016-06-28) Opensource License (2016-06-29) FileIO (2016-06-30) Fundamental of Database (2016-07-01) Memory Management (2016-07-02) Regular Expression (2016-07-03) Queue (2016-07-04) OSI 7 layer and TCP/IP model (2016-07-05~2016-07-10) Android Permission","categories":[{"name":"life","slug":"life","permalink":"http://lazyrodi.github.io/categories/life/"}],"tags":[]},{"title":"동영상 모음","slug":"2016-06-22-docthread-video-collecting","date":"2016-06-22T11:01:00.000Z","updated":"2016-07-18T11:42:38.106Z","comments":true,"path":"2016/06/22/2016-06-22-docthread-video-collecting/","link":"","permalink":"http://lazyrodi.github.io/2016/06/22/2016-06-22-docthread-video-collecting/","excerpt":"","text":"개발자가 보면 암걸리는 동영상 산으로 가는 광고 오늘 미래를 만나다 - 허태균 교수 : 대한민국에서 행복 찾기 자기 적성을 몰라 헤매는 당신이 반드시 들어야 할 대답 : 송길영 다음소프트 부사장 How a CPU Works","categories":[{"name":"docs","slug":"docs","permalink":"http://lazyrodi.github.io/categories/docs/"}],"tags":[{"name":"docs, video","slug":"docs-video","permalink":"http://lazyrodi.github.io/tags/docs-video/"}]},{"title":"[조직문화] 회의","slug":"2016-06-22-hr-conference","date":"2016-06-22T11:00:00.000Z","updated":"2016-07-11T13:34:35.465Z","comments":true,"path":"2016/06/22/2016-06-22-hr-conference/","link":"","permalink":"http://lazyrodi.github.io/2016/06/22/2016-06-22-hr-conference/","excerpt":"","text":"실리콘밸리 임원들이 회의 하는 법 - www.andrewahn.co신속한 합의를 위한 5일의 법칙 - www.andrewahn.co","categories":[{"name":"hr","slug":"hr","permalink":"http://lazyrodi.github.io/categories/hr/"}],"tags":[{"name":"hr, conference","slug":"hr-conference","permalink":"http://lazyrodi.github.io/tags/hr-conference/"}]},{"title":"UX","slug":"2016-06-22-docthread-ux","date":"2016-06-22T10:47:50.000Z","updated":"2016-07-11T13:04:48.134Z","comments":true,"path":"2016/06/22/2016-06-22-docthread-ux/","link":"","permalink":"http://lazyrodi.github.io/2016/06/22/2016-06-22-docthread-ux/","excerpt":"","text":"같은 듯 다른 사용자경험(UX)과 고객경험(CX)","categories":[{"name":"docs","slug":"docs","permalink":"http://lazyrodi.github.io/categories/docs/"}],"tags":[{"name":"docs, ux","slug":"docs-ux","permalink":"http://lazyrodi.github.io/tags/docs-ux/"}]},{"title":"JS Library","slug":"2016-06-22-docthread-jslibrary","date":"2016-06-22T10:47:50.000Z","updated":"2016-07-11T13:05:07.063Z","comments":true,"path":"2016/06/22/2016-06-22-docthread-jslibrary/","link":"","permalink":"http://lazyrodi.github.io/2016/06/22/2016-06-22-docthread-jslibrary/","excerpt":"","text":"Visualization d3.js - 데이터 시각화 typed.js - 타이핑 효과… 뭐라고 설명을 써야할지… Wysiwyg Editor 10 best html wysisyg plugin - Froala, ContentTools, Raptor Editor, Aloha, TinyMCE, bootstrap3-wysiwyg, summernote, CKEditor, Trumbowyg, Redactor 브라우저 기반의 위지윅 에디터 총집합 CSS bootstrap bootstrap-material-design ETC 추천 JavaScript Library 정리 - Brunch의 @klaus님 글","categories":[{"name":"docs","slug":"docs","permalink":"http://lazyrodi.github.io/categories/docs/"}],"tags":[{"name":"docs, js, visualization, wysiwyg editor, css","slug":"docs-js-visualization-wysiwyg-editor-css","permalink":"http://lazyrodi.github.io/tags/docs-js-visualization-wysiwyg-editor-css/"}]},{"title":"[JavaScript] Document Word Parser","slug":"2016-06-07-works-document-word-parser","date":"2016-06-06T15:20:00.000Z","updated":"2016-07-11T12:53:29.753Z","comments":true,"path":"2016/06/07/2016-06-07-works-document-word-parser/","link":"","permalink":"http://lazyrodi.github.io/2016/06/07/2016-06-07-works-document-word-parser/","excerpt":"","text":"Document Word Parser Use : http://lazyrodi.github.io/misc/DocumentWordParser.html Repository : https://github.com/lazyrodi/misc/tree/master/DocumentWordParser UsageParse the document word by word. Input document in textarea left side. Run You can see word-frequency on the right side. Ignore uppercase/lowercase and some characters-, . ‘ “ ( ) { } [ ] ? !-.","categories":[{"name":"works","slug":"works","permalink":"http://lazyrodi.github.io/categories/works/"}],"tags":[{"name":"parser, javascript","slug":"parser-javascript","permalink":"http://lazyrodi.github.io/tags/parser-javascript/"}]},{"title":"[조직문화] 명언, 격언","slug":"2016-05-01-hr-famous-saying","date":"2016-05-16T11:00:00.000Z","updated":"2016-07-11T13:38:03.488Z","comments":true,"path":"2016/05/16/2016-05-01-hr-famous-saying/","link":"","permalink":"http://lazyrodi.github.io/2016/05/16/2016-05-01-hr-famous-saying/","excerpt":"","text":"직원들은 다른 회사에서 더 나은 직책이나 연봉을 제안받았을 때가 아니라 지금 회사에서 존중받지 못했을 때 이직한다. Tom MendozaNetApp Vice president 단순함, 그것은 천재에게 주어진 재능이다.어떤 지적인 바보도 사물을 더 크고, 더 복잡하고, 더 격렬하게 만들 수 있다.하지만 그 반대편으로 나아가려면 약간의 천재성과 많은 용기가 필요하다.만약 당신이 어떤 것을 단순하게 설명할 수 없다면, 당신은 그것을 충분히 이해하지 못한 것이다. Albert Einstein (알버트 아인슈타인) 더 더할게 없을 때가 아니라, 더 뺄게 없을 때 완벽한 디자인에 도달할 수 있다. Antoine Marie Roger De Saint Expery (생텍쥐페리)","categories":[{"name":"hr","slug":"hr","permalink":"http://lazyrodi.github.io/categories/hr/"}],"tags":[{"name":"hr, famours saying","slug":"hr-famours-saying","permalink":"http://lazyrodi.github.io/tags/hr-famours-saying/"}]},{"title":"SQL 기초","slug":"2016-04-13-db-sql-getting-started","date":"2016-05-13T04:00:00.000Z","updated":"2016-07-18T15:08:47.491Z","comments":true,"path":"2016/05/13/2016-04-13-db-sql-getting-started/","link":"","permalink":"http://lazyrodi.github.io/2016/05/13/2016-04-13-db-sql-getting-started/","excerpt":"","text":"SQL 명령어 SELECT : database로부터 data를 추출한다. UPDATE : database내의 data를 갱신한다. DELETE : database로부터 data를 삭제한다. INSERT INTO : database로 새로운 data를 삽입한다. CREATE DATABASE : 새로운 database를 생성한다. ALTER DATABASE : database를 수정한다. CREATE TABLE : 새 table을 생성한다. ALTER TABLE : table을 수정한다. DROP TABLE : table을 삭제한다. CREATE INDEX : index (search key)를 생성한다. DROP INDEX : index를 삭제한다. SELECT table로부터 선택한 column들을 전부 읽어서 보여준다. * 은 모든 column. 12SELECT column_name, column_name FROM table_name;SELECT * FROM table_name; 중복되는 data는 제외하고 보고싶을 때 DISTINCT 구문을 사용한다. (예를 들어 city 정보에 seoul을 갖는 record가 두 개 있을 때 하나만 보여준다.) 1SELECT DISTINCT column_name, column_name FROM table_name; WHERE 절은 특별한 기준을 만족시키는 record만 추출한다. Text value는 작은 따옴표, Numeric value에는 따옴표 없이 사용한다. OperatorDescription=Equal&lt;&gt;Not Equal&gt;Greater than&lt;Less than&gt;=Greater than or equal&lt;=Less than or equalBETWEENBetween an inclusive rangeLIKESearch for a patternINTo specify multiple possible values for a column 12SELECT column_name, column_name FROM table_name WHERE column_name operator value;SELECT * FROM Customers WHERE Country='Mexico'; AND와 OR의 경우 다음과 같이 사용 가능하다. 12SELECT * FROM Customers WHERE Country='Germany' AND City='Berlin';SELECT * FROM Customers WHERE Country='Germany' AND (City='Berlin' or City='Munchen'); ORDER BY keyword를 이용하여 오름차순으로 정렬해서 볼 수 있다. 내림차순 정렬을 위해서는 DESC keyword를 사용하면 된다. 1234SELECT column_name, column_name FROM table_name ORDER BY column_name ASC|DESC, column_name ASC|DESC;SELECT * FROM Customers ORDER BY Country;SELECT * FROM Customers ORDER BY Country DESC;SELECT * FROM Customers ORDER BY Country ASC, CustomerName DESC; INSERT INTO 구문은 table에 새로운 record를 삽입하는 것으로 두 가지 방식으로 사용할 수 있다. 123INSERT INTO table_name VALUES (value1,value2,value3,...);INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...);INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country) VALUES ('Cardinal','Tom B. Erichsen','Skagen 21','Stavanger','4006','Norway'); UPDATE 구문은 table 내에 존재하는 record를 갱신하는 기능이다. WHERE구문을 사용하지 않는다면 모든 record들이 갱신되므로 반드시 올바르게 사용하여야 한다. 12UPDATE table_name SET column1=value1, column2=value2, ... WHERE some_column=some_value;UPDATE Customers SET ContactName='Alfred Schmidt', City='Hamburg' WHERE CustomerName='Alfreds Futterkiste'; DELETE 구문은 table 내의 row를 삭제한다. WHERE를 사용하지 않으면 모두 삭제되므로 반드시 주의하자. 12DELETE FROM table_name WHERE some_column=some_value;DELETE FROM Customers WHERE CustomerName='Alfreds Futterkiste' AND ContactName='Maria Anders'; 모든 Data를 삭제하기 위해서는 다음 둘 중 하나를 사용하면 된다. 복구할 수 없으므로 모쪼록 주의하자. 12DELETE FROM table_name;DELETE * FROM table_name;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"database","slug":"Dev/database","permalink":"http://lazyrodi.github.io/categories/Dev/database/"}],"tags":[{"name":"database, sql","slug":"database-sql","permalink":"http://lazyrodi.github.io/tags/database-sql/"}]},{"title":"Web","slug":"2016-04-02-docthread-web","date":"2016-04-02T10:47:50.000Z","updated":"2016-07-11T13:03:25.541Z","comments":true,"path":"2016/04/02/2016-04-02-docthread-web/","link":"","permalink":"http://lazyrodi.github.io/2016/04/02/2016-04-02-docthread-web/","excerpt":"","text":"HTTP REST API 디자인 - 조대협님의 강의자료","categories":[{"name":"docs","slug":"docs","permalink":"http://lazyrodi.github.io/categories/docs/"}],"tags":[{"name":"docs, web","slug":"docs-web","permalink":"http://lazyrodi.github.io/tags/docs-web/"}]},{"title":"[RoR] Rails-flavored Ruby","slug":"2016-04-02-ruby-on-rails-rails-flavored-ruby","date":"2016-04-01T15:04:00.000Z","updated":"2016-07-11T13:53:37.253Z","comments":true,"path":"2016/04/02/2016-04-02-ruby-on-rails-rails-flavored-ruby/","link":"","permalink":"http://lazyrodi.github.io/2016/04/02/2016-04-02-ruby-on-rails-rails-flavored-ruby/","excerpt":"","text":"Rails 에서는 Ruby 중 일부를 사용할 수 있다. 아래는 application.css 파일을 link하는 것이다. 일단 이건 뒤에서 다시 보자.1&lt;%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' =&gt; true %&gt; String and Method 주석은 # 으로 처리한다. String은 &quot;&quot; 으로 처리하며 다음과 같은 연산들이 가능하다. &#39;&#39; 도 가능하지만 single quotation은 interpolation 기능을 지원하지 않는다. interpolation은 #{ } 를 통해 변수를 따옴표 안에서 사용할 수 있는 기능이다.12345678&gt;&gt; \"foo\" + \"bar\"&gt;&gt; first_name = \"Michael\"&gt;&gt; \"#&#123;first_name&#125; Hartl\" #interpolation&gt;&gt; first_name + \"Hartl\"&gt;&gt; \"foobar\".length #get length&gt;&gt; \"foobar\".empty? #true/false&gt;&gt; \"foobar\".nil? #true/false print는 puts &quot;foo&quot; 의 방식으로 한다. if문은 다음과 같은 방식으로 사용한다. &amp;&amp;, ||, ! 으로 논리식을 표현한다.12345678if s.nil? \"abc\"elseif s.empty? \"def\"else \"gkl\"end 아래 방식으로 출력문에 조건문을 더할 수도 있다.123x = \"foo\"puts x if !x.empty? String으로 변환은 abc.to_s 으로 가능하다. if문 대신 unless문을 사용할 수 있는데, if는 조건이 true일 때 실행되고 unless는 조건이 false일 때 실행된다.123x = \"foo\"puts x unless x.empty? Method definitions method 선언의 간단한 예이다. method 호출 시 parameter가 하나 있으면 str에 들어가고 없으면 기본 값으로 &#39;&#39;를 사용한다. 1234567def string_message(str = '') if str.empty? \"empty string\" else \"not empty string\"end Ruby 함수는 implicit return을 지원한다. 한 statement의 마지막에 있는 것을 return한다. return을 기입하는 explicit return 역시 지원한다. 12345def string_message(str = '') return \"abc\" if str.empty? return \"nonempty\"end Array는 다음과 같이 편하게 생성할 수도 있다. 12345678910111213141516171819&gt;&gt; \"foo bar baz\".split # [\"foo\", \"bar\", \"baz\"]&gt;&gt; \"fooxbarxbazx\".split('x') # [\"foo\", \"bar\", \"baz\"]&gt;&gt; a = [42, 8, 17]&gt;&gt; a[0] # 42&gt;&gt; a[-1] # 17&gt;&gt; a.first&gt;&gt; a.second&gt;&gt; a.last&gt;&gt; a.length&gt;&gt; a.empty?&gt;&gt; a.include?(3) # true&gt;&gt; a.sort # [8, 17, 42]&gt;&gt; a.reverse # [17, 8, 42]&gt;&gt; a.shuffle # [17, 42, 8] 이건 랜덤으루다가.&gt;&gt; a # [42, 8, 17] 변하지 않음&gt;&gt; a.sort! # [8, 17, 42]&gt;&gt; a # [8, 17, 42] 변했음 위에서 ! 를 Bang method라 한다. &lt;&lt; 연산자를 통해 배열에 새로운 아이템을 넣을 수 있다. 1234&gt;&gt; a.push(5) # [42, 8, 17, 5]&gt;&gt; a &lt;&lt; 7 # [42, 8, 17, 5, 7]&gt;&gt; a &lt;&lt; \"foo\" &lt;&lt; \"bar\" # [42, 8, 17, 5, 7, \"foo\", \"bar\"] .. 을 통해 range를 나타낼 수 있다. to_a 는 array를 생성해 준다. 12345678910&gt;&gt; 0..9&gt;&gt; 0..9.to_a # error. 이건 9.to_a 와 같다.&gt;&gt; (0..9).to_a # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt; a = %w[foo bar baz quux] # %w 는 string array를 만들어 준다.&gt;&gt; a[0..2] # [\"foo\", \"bar\", \"baz\"]&gt;&gt; a[2..(a.length-1)] # [2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt; a[2..-1] # [2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt; ('a'..'e').to_a # [\"a\", \"b\", \"c\", \"d\", \"e\"] Ruby의 강력한 기능 중 하나인 Block은 다음과 같다. 12&gt;&gt; (1..5).each &#123; |i| puts 2 * i &#125; #2 4 6 8 10 이 출력된다. |i| 는 Block variable 이라고 부른다. { } 를 사용하지 않고도 같은 효과를 낼 수 있다. 1234(1..5).each do |i| puts 2 * iend 보통 Rails에서는 one-line일 때에는 block을 사용하고 multi-line일 때는 do..end 구문을 사용한다. map 메소드를 통해 다음과 같은 변환도 가능하다. 12345&gt;&gt; 3.times &#123; puts \"abc\" &#125; # abc를 세 번 출력&gt;&gt; (1..5).map &#123; |i| i**2 &#125; # [1, 4, 9, 16, 25]&gt;&gt; %w[a b c].map &#123; |char| char.upcase &#125; # [A, B, C] 로 바뀜&gt;&gt; join 메소드는 배열을 하나의 String으로 변환시켜준다. 아래 코드는 a ~ z 중 임의의 8가지 문자로 배열을 생성하고 이를 합쳐서 하나의 String으로 만들어준다. 12&gt;&gt; ('a'..'z').to_a.shuffle[0..7].join 다음과 같이 hash를 사용할 수 있다. 123456789&gt;&gt; user = &#123;&#125; # empty hash&gt;&gt; user[\"first\"] = \"Michael\" # Key : first , Value : Michael&gt;&gt; user[\"last\"] = \"Hartl\" # Key : last , Value : Hartl&gt;&gt; user[\"first\"] # return \"Michael\"&gt;&gt; user # return &#123;\"last\"=&gt;\"Hartl\", \"first\"=&gt;\"Michael\"&#125;# 처음부터 이렇게 선언도 가능함. =&gt; 를 \"hashrocket\" 이라 부른다.&gt;&gt; useruser = &#123;\"first\"=&gt;\"Michael\", \"last\"=&gt;\"Hartl\"&#125; Ruby에서의 symbol은 :name 처럼 콜론으로 시작한다. 숫자로 시작할 수 없고 dash ‘-‘ 를 사용할 수 없다. hash에서 다음과 같이 사용할 수 있다. Ruby에서는 hash끼리의 비교도 가능하다. hash A, B 가 있을 때 ‘A == B’ 식으로… 1234&gt;&gt; user = &#123; :name=&gt;\"Michael Hartl\", :email=&gt;\"michael@ex.com\" &#125;&gt;&gt; user[:name] # return \"Michael Hartl\"&gt;&gt; user[:passwd] # return nil 다음과 같은 방식으로도 hash를 선언할 수 있으나 :name 과 다르게 name은 독자적으로 사용할 수 없다. 말이 좀 어려운데 아래처럼 선언해도 사용할 때는 user[:name] 형식이 된다는 말이다. 12&gt;&gt; user = &#123; name: \"abc\", email: \"asdf\" &#125; Nested hash 형식도 가능하다. 12345&gt;&gt; params = &#123;&#125;&gt;&gt; params[:user] = &#123;name: \"asdf\", age: \"55\"&#125;&gt;&gt; params # return &#123;:user=&gt;&#123;:name=&gt;\"asdf\", :age=&gt;\"55\"&#125;&#125;&gt;&gt; params[:user][:age] # \"55\" inspect 메소드는 변수를 문자 그대로(literally) 출력한다. puts + inspect 를 줄여서 p 로 쓸 수도 있다. 12345678910&gt;&gt; puts :name, :name.inspect # name # :name&gt;&gt; puts \"it worked\", \"it worked\".inspect # it worked # \"it worked\"&gt;&gt; puts :name.inspect # :name&gt;&gt; p :name # :name 위에서 나왔던 아래 소스를 살펴보자.ruby는 괄호(parentheses)( ) 및 중괄호(braces){ }를 생략할 수 있다.즉, 아래 소스는 stylesheet_link_tag 라는 이름의 함수이다. stylesheet_link_tag 함수는 두 개의 인자를 갖는다. string (stylesheet의 path) hash media type Rails 4.0에 추가된 turbolinks 기능의 사용 여부123456&lt;%= stylesheet_link_tag 'application', media: 'all', 'data-turbolinks-track' =&gt; true %&gt;# 아래와 같이 표현될 수 있다.&lt;%= stylesheet_link_tag ('application', &#123; media: 'all', 'data-turbolinks-track' =&gt; true &#125; ) %&gt;# 'data-turbolinks-track' 이 =&gt; (hashrocket) 을 사용한 이유는 변수명에 dash '-' 가 들어갈 수 없기 때문이다.# Ruby는 new line이나 space에 제한을 받지 않으므로 맘대로 끊어쓰면 된다. 보통 80 글자 기준으로 엔터 치는 듯 하다. &lt;%= %&gt; 로 둘러싸여있는 구문은 ERb에 의해 HTML에 들어가게 된다. 브라우저의 소스 보기를 통해 보면 다음과 같이 보이게 된다. :true12&lt;link data-turbolinks-track=&quot;true&quot; href=&quot;/assets/application.css&quot; media=&quot;all&quot; rel=&quot;stylesheet&quot;&gt; Ruby classes Ruby는 객체 지향 언어이기 때문에 method의 집합인 class로 이루어져 있고, 초기화를 통해 object를 생성한다. 이로 인한 몇 가지 특성을 보자. Constructor 123456&gt;&gt; s = \"foobar\"&gt;&gt; s = String.new(\"foobar\")&gt;&gt; a = Array.new([1,3,2])&gt;&gt; h = Hash.new&gt;&gt; h = Hash.new(0) # 인자들을 0으로 초기화 Class inheritance 12345678&gt;&gt; s = String.new(\"foobar\")&gt;&gt; s.class # String&gt;&gt; s.class.superclass # Object&gt;&gt; s.class.superclass.superclass # BasicObject&gt;&gt; s.class.superclass.superclass.superclass # nil&gt;&gt; class ABC &lt; String # 상속 build-in class 수정하기 JavaScript의 navigator와 비슷한 개념인가 싶은데… override는 아니고 직접 그 class를 다시 선언해서 native class의 method를 수정하여 사용할 수 있다.1234567&gt;&gt; class String&gt;&gt; # Returns true if the string is its own reverse.&gt;&gt; def palindrome?&gt;&gt; self == self.reverse&gt;&gt; end&gt;&gt; end blank와 empty의 차이. (irb에서는 지원하지 않는다. ERb에서 되는지는 안해봤지만 되니까 써놓지 않았을까…) 12345&gt;&gt; \"\".blank? # true&gt;&gt; \" \".empty? # false&gt;&gt; \" \".blank? # true&gt;&gt; nil.blank? # true Controller class Controller class는 다음과 같은 상속 구조를 갖는다. StaticPagesController &lt; ApplicationController &lt; ActionController::Base &lt; ActionController::Metal &lt; AbstractController::Base &lt; Object User model에 대해 살펴보자. 12345678910111213class User attr_accessor :name, :email def initialize(attributes = &#123;&#125;) @name = attributes[:name] @email = attributes[:email] end def formatted_email \"#&#123;@name&#125; &lt;#&#123;@email&#125;&gt;\" endend attribute accessors는 getter와 setter 메소드를 만들겠다는 의미이다. @name, @email instance 변수에 대해 retrieve(get), assign(set)을 도와준다.instance 변수는 언제나 @로 시작하며, 정의하지 않을 시 nil 이 된다 위의 initialize 메소드는 User.new 를 수행하면 호출된다. initialize는 attributs: 라는 하나의 인자만 갖는다. 위 코드를 통해 인자는 Hash값이라는 것을 알 수 있다. 책의 예제에서는 console에서 위 파일을 가져와서 수행했는데 파일을 가져오기 위해서는 require 메소드를 사용한다. 파일명도 생략한다. require &#39;./example_user&#39;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"Ruby on rails","slug":"Dev/Ruby-on-rails","permalink":"http://lazyrodi.github.io/categories/Dev/Ruby-on-rails/"}],"tags":[{"name":"ruby on rails, ruby","slug":"ruby-on-rails-ruby","permalink":"http://lazyrodi.github.io/tags/ruby-on-rails-ruby/"}]},{"title":"Android Default Skills","slug":"2016-04-01-android-default-skills","date":"2016-04-01T11:00:00.000Z","updated":"2016-07-11T13:53:57.789Z","comments":true,"path":"2016/04/01/2016-04-01-android-default-skills/","link":"","permalink":"http://lazyrodi.github.io/2016/04/01/2016-04-01-android-default-skills/","excerpt":"","text":"SkillCall other activity1startActivity(new Intent(MainActivity.this, InputActivity.class)); Icons https://design.google.com/icons/index.html Trouble Shooting actual argument android.widget.Toolbar cannot be converted to android.support.v7.widget.Toolbar by method invocation conversion import android.widget.Toolbar; 대신 import android.support.v7.widget.Toolbar; 로 한다. setSupportActionBar(); 의 사용때문에 나온 에러이며, 이건 뒤의 라이브러리에 들어있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"android","slug":"Dev/android","permalink":"http://lazyrodi.github.io/categories/Dev/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://lazyrodi.github.io/tags/android/"}]},{"title":"Linux Command","slug":"2016-03-26-linux-command","date":"2016-03-26T10:47:50.000Z","updated":"2016-07-11T13:54:52.895Z","comments":true,"path":"2016/03/26/2016-03-26-linux-command/","link":"","permalink":"http://lazyrodi.github.io/2016/03/26/2016-03-26-linux-command/","excerpt":"","text":"리눅스 명령어 개인적으로 많이 사용하고 헤깔리는 것들에 대해 정리한 것이며, 자세한 것은 --help 를 통해 확인하자. apt-get ubuntu 계열에서 package(windows에서는 프로그램, 유틸리티, ETC…)를 설치/제거/업데이트 등을 위해 사용하는 유틸리티. apt는 advanced package tool을 의미.apt-get install 패키지명apt-get remove 패키지명 chown change ownerchown 계정:그룹 경로 df display filesystem. filesystem 사용 용량 등의 정보를 알려준다. 보통 df -h 를 통해서 확인한다.df -h ifconfig windows의 ipconfig. ip 정보를 보여준다. ifconfig link 디렉토리 설정 시 경로는 절대경로로 넣자.ln -s 원본디렉토리 [link디렉토리] screen .screenrc 에 환경설정 가능","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"linux","slug":"Dev/linux","permalink":"http://lazyrodi.github.io/categories/Dev/linux/"}],"tags":[{"name":"linux, command, apt-get, chown, df, ifconfig, link, screen","slug":"linux-command-apt-get-chown-df-ifconfig-link-screen","permalink":"http://lazyrodi.github.io/tags/linux-command-apt-get-chown-df-ifconfig-link-screen/"}]},{"title":"[RoR] CRUD","slug":"2016-03-25-ruby-on-rails-crud","date":"2016-03-24T15:01:00.000Z","updated":"2016-07-11T13:53:32.965Z","comments":true,"path":"2016/03/25/2016-03-25-ruby-on-rails-crud/","link":"","permalink":"http://lazyrodi.github.io/2016/03/25/2016-03-25-ruby-on-rails-crud/","excerpt":"","text":"https://www.railstutorial.org/book/static_pages 를 보고 공부한 내용. CRUD CRUD 는 아래 네 가지를 뜻한다. 위키백과를 참조하자 - Create - Read - Update - Delete MVC Ruby on rails는 MVC(Model View Controller)로 설계되어 있다. 위키백과를 참조하자 scaffold rails는 scaffold 를 통해 간단하게 MVC 를 생성할 수 있게 해준다.다음 명령어를 통해 User 를 생성해본다. 1rails generate scaffold User name:string email:string Rake Rake는 Ruby + Make를 합친 명령어이다. 위에서 생성한 User model(DB)을 사용하기 위해 database를 migration 해야 한다. 명령어에 대한 자세한 내용은 Stackoverflow의 질문내용에서 잘 설명해주고 있다. database task list를 보기 위해서는 bundle exec rake -T db 명령을 입력하면 된다.실행하면 users에 대해 create_table 해주는 것을 볼 수 있다. 또한, 이 내역은 application의 /db/migrate 디렉토리에 저장된다. 1bundle exec rake db:migrate 생성한 User 확인하기 이제 다시 서버를 실행rails server -b .... -p 3000한 후 브라우저에서 주소 뒤에 /users/new를 입력해 보자. User 생성 page를 볼 수 있다. 엄청 간단하게 CRUD 기능을 지원하는 Web site를 생성한 것이다. 생성된 URL은 다음과 같고 아래와 같은 의미를 갖는다. URL Action Purpose /users index page to list all users /users/1 show page to show user with id 1 /users/new new page to make a new user /users/1/edit edit page to edit user with id 1 rails에서의 MVC 패턴 동작을 그림으로 나타내면 아래와 같다.(출처 : https://www.railstutorial.org/book/toy_app) 123456781. The browser issues a request for the /users URL.2. Rails routes /users to the index action in the Users controller.3. The index action asks the User model to retrieve all users (User.all).4. The User model pulls all the users from the database.5. The User model returns the list of users to the controller.6. The controller captures the users in the @users variable, which is passed to the index view.7. The view uses embedded Ruby to render the page as HTML.8. The controller passes the HTML back to the browser. gem - gem install bootstrap-material-design - 아래 gem들이 같이 설치된다. - autoprefixer-rails-6.3.6 - bootstrap-sass-3.3.6 - bootstrap-material-design-0.2.2","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"Ruby on rails","slug":"Dev/Ruby-on-rails","permalink":"http://lazyrodi.github.io/categories/Dev/Ruby-on-rails/"}],"tags":[{"name":"ruby on rails, crud","slug":"ruby-on-rails-crud","permalink":"http://lazyrodi.github.io/tags/ruby-on-rails-crud/"}]},{"title":"[RoR] Settings","slug":"2016-03-20-ruby-on-rails-setting","date":"2016-03-19T15:01:00.000Z","updated":"2016-07-11T13:53:23.652Z","comments":true,"path":"2016/03/20/2016-03-20-ruby-on-rails-setting/","link":"","permalink":"http://lazyrodi.github.io/2016/03/20/2016-03-20-ruby-on-rails-setting/","excerpt":"","text":"회사에서 존경하는 선배님과 함께 Ruby on rails를 이용하여 스터디를 진행하기로 하였다. Virtualbox를 설치하고 Ubuntu 환경에서 진행하였다. https://www.railstutorial.org/book/static_pages 를 보고 공부한 내용. Ruby on rails 란? Rails는 Ruby 언어에서 동작하는 Web Application Framework이다. 단순한 코드로 CRUD를 쉽게 구현할 수 있다고 한다. 제대로 사용할 줄 알면 빠른 시간 내에 웹 서비스를 구축할 수 있다. Ruby on rails 세팅 rbenv 설치rbenv는 이름에서도 유추 가능하듯 Ruby Environment의 관리 편의를 제공한다. Ruby on rails application 별로 다른 ruby version을 유지할 수 있게 해준다. rbenv Command Reference에서 자세한 정보를 확인할 수 있다. 설명서대로 설치를 진행해본다. ~/.rbenv 에 땡겨온다.1$ git clone https://github.com/rbenv/rbenv.git ~/.rbenv $PATH에 ~/.rbenv/bin 을 추가한다. 그리고 적용을 위해 source .bashrc를 수행한다.1$ echo 'export PATH=\"$HOME/.rbenv/bin:$PATH\"' &gt;&gt; ~/.bashrc 다음 명령을 통해 shell에 관계 없이 rbenv를 자동으로 초기화할 수 있다.1$ ~/.rbenv/bin/rbenv init ruby-build를 추가로 설치하자. 이를 통해 rbenv install 명령어를 사용할 수 있게 된다. 설치 후 rbenv install -l 명령을 수행하면 설치 가능한 ruby의 version들이 쫙나온다.1$ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build 나는 2.3.0 을 설치해 보기로 했다. rbenv install 2.3.0 명령으로 간단하게 ruby를 설치할 수 있다. 한 번 실패했는데 sudo apt-get install -y libssl-dev libreadline-dev zlib1g-dev를 설치했어야 했다. rbenv versions 명령을 통해 현재 설치/설정된 ruby version들을 볼 수 있다. rbenv local 2.3.0 으로 local 계정에 적용되는 ruby version을 2.3.0으로 변경하였다. 추가로, 새 version의 ruby나 gem을 설치하게 되면 변경된 실행 정보를 알리기 위해 rbenv rehash 명령을 수행해야 한다. 다음은 gem을 이용하여 bundler를 설치한다. gem이란 ruby의 plugin 정도로 이해하면 편하겠다. ruby에 종속된다. bundler란 모듈을 한데 모아서 관리하는 것이다. ruby의 경우 gem들을 모아서 관리하는 주체라고 보면 되겠다. gem install bundler 로 bundler gem을 설치할 수 있으며, sudo 권한은 필요치 않다. rbenv를 통해 ruby version을 변경할 경우 그 버전에 맞는 gem을 추가로 설치해야 한다. 그런데 에러가 났다. 에러 내용은 이렇게.12ERROR: While executing gem ... (Errno::EACCES) Permission denied @ dir_s_mkdir - /var/lib/gems rbenv를 통해 설치한 ruby는 ~/.rbenv/versions/2.3.0/bin에 있는데 system에 기본 설치된 ruby가 실행되어 생기는 문제이다. ~/.bashrc 에 경로를 추가해두자. rbenv에서 이것까지 관리가 될 것 같은데 뭔가 좀 이상하다. 그래도 일단은 해결하고 넘어가자.1$ echo 'export PATH=\"$HOME/.rbenv/versions/2.3.0/bin:$PATH\"' &gt;&gt; ~/.bashrc rails 설치이제 ruby의 설치가 끝났다. rails 세팅에 돌입하자. rails는 ruby gem 중 하나이다. THE RUBY ON RAILS TUTORIAL 를 베이스로 진행한다.1$ gem install rails rails project 생성 아래의 명령으로 ‘blog’라는 이름을 갖는 rails project(application)을 생성할 수 있다.1$ rails new blog rails application은 아래의 명령을 통해 실행한다.1$ rails server 일단 에러가 날 것이다. 이유는 해당 application이 필요로 하는 gem들이 설치되지 않아서이다.필요로 하는 gem들의 정보는 “Gemfile” 에 선언되어 있고, 구현하고자 하는 application에서 사용할 gem들을 직접 정의해 줄 수도 있다. 아래 명령으로 gem들을 설치한다.1$ bundle install 내 pc(virtual box로 돌리는 ubuntu) 기준으로 아래와 같은 에러가 발생한다.An error occured while installing sqlite3 (1.3.11), and Bundler cannot continue.Make sure that ‘gem install sqlite3 -v ‘1.3.11’’ succeeds before building. 시키는대로 설치를 해보자.1$ gem install sqlite3 -v '1.3.11' 에러를 뿜는다. 이번에는 apt-get install libsqlite3-dev 를 설치하라고 한다. 하고 sqlite3 gem을 install하자. 자, 이제 대망의 rails server 를 실행한다. 또 에러가 난다… Could not find gem &#39;sass-rails (~&gt;5.0)&#39; in any of the gem sources listed in your Gemfile or available on this machine. … 힘들다. gem install sass-rails 를 통해 최신 버전을 설치한 후 bundle install 그리고 rails server 를 다시 실행한다. 이번에는 다음과 같은 에러가 발생했다. 1/home/user/.rbenv/versions/2.3.0/lib/ruby/gems/2.3.0/gem/bundler-1.11.2/lib/bundler/runtime.rb:80:in 'rescue in block (2 levels) in requir': There was an error while trying to load the gem 'uglifier'. 그냥 구글에 검색해본다. 검색 뚝딱뚝딱 그렇다. stackoverflow에 답이 있다. apt-get install nodejs 후 rails server를 하니 드디어 된다. uglifier가 뭔지 찾아보니 JavaScript parser, minifier, compressor, beautifier 등의 역할을 하는 툴인 것 같다. 나중에 기회가 되면 알아보자. 이제 브라우저에서 localhost:3000 을 입력하면 접속이 되어야 한다. 나의 경우 virtualbox에서 실행하였으므로, 네트워크 브리지를 통해 Windows의 Browser를 통해 접속하여 확인하였다. VirtualBox 리눅스 SSH 연결 (브리지)를 참조하였으며, ifconfig를 통해 Virtual box에 할당된 IP를 알아낼 수 있는데 rails 실행 시 옵션을 추가해 주어야 제대로 된 실행 결과를 볼 수 있다. 00.00.00.00은 ifconfig를 통해 알아낸 IP를 적고, 3000 자리에는 마음에 드는 port number를 적어준다. 그리고 Windows의 Browser에서 00.00.00.00:3000 으로 접속하면 드디어 Welcome aboard 화면을 볼 수 있게 된다. 1rails server -b 00.00.00.00 -p 3000 Virtual box 공유폴더 설정 1234561. 장치 -&gt; 공유 폴더 -&gt; 공유 폴더 설정2. 장치 -&gt; 게스트확장 이미지 삽입3. /media/sf_폴더이름 으로 생긴 것 확인4. 폴더의 Group permission이 vboxsf로 되어있으므로 아래 명령으로 계정을 그룹에 추가 - sudo gpasswd -a 계정명 vboxsf5. reboot 명령으로 시스템 재부팅 경로를 돌아가는 것이 불편하여 아래와 같이 symbolic ilnk를 걸어 사용하기로 한다.1sudo ln -s /media/sf_shared ~/shared","categories":[{"name":"Dev","slug":"Dev","permalink":"http://lazyrodi.github.io/categories/Dev/"},{"name":"Ruby on rails","slug":"Dev/Ruby-on-rails","permalink":"http://lazyrodi.github.io/categories/Dev/Ruby-on-rails/"}],"tags":[{"name":"ruby on rails, settings","slug":"ruby-on-rails-settings","permalink":"http://lazyrodi.github.io/tags/ruby-on-rails-settings/"}]},{"title":"First posting - Jekyll 작업 완료","slug":"2016-03-19-life-first-posting","date":"2016-03-19T11:00:00.000Z","updated":"2016-07-11T13:53:20.332Z","comments":true,"path":"2016/03/19/2016-03-19-life-first-posting/","link":"","permalink":"http://lazyrodi.github.io/2016/03/19/2016-03-19-life-first-posting/","excerpt":"","text":"Jekyll 작업 완료. 신문물이 아무리 많아도 알지 못하고 사용하지 못한다면 무용지물이다. 이미 늦었을지도 모르지만 더 늦기 전에 하나씩 따라잡아보기로 하자. 일단은 github.io 계정 생성, Jekyll 작업 완료. 작심삼일이 되지 않기를 바라며.","categories":[{"name":"life","slug":"life","permalink":"http://lazyrodi.github.io/categories/life/"}],"tags":[]}]}